var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Fortran program for the calculation of the residual Helmholtz Energy using the\nRKPR EoS (hence, PR and SRK are also included). Developer Info Federico Benelli Doctoral student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"jsonfortrantest.f90 – Fortran Program","text":"Contents Programs jsonfortrantest Source Code jsonfortrantest.f90 Source Code !***************************************************************************************** !> !  Entry point for the unified unit test application. ! !  Runs all the tests in the `tests` folder !  Returns `1` if there are any errors. program jsonfortrantest use jf_test_1_mod , only : test_1 use jf_test_2_mod , only : test_2 use jf_test_3_mod , only : test_3 use jf_test_4_mod , only : test_4 use jf_test_5_mod , only : test_5 use jf_test_6_mod , only : test_6 use jf_test_7_mod , only : test_7 use jf_test_8_mod , only : test_8 use jf_test_9_mod , only : test_9 use jf_test_10_mod , only : test_10 use jf_test_11_mod , only : test_11 use jf_test_12_mod , only : test_12 use jf_test_13_mod , only : test_13 use jf_test_14_mod , only : test_14 use jf_test_15_mod , only : test_15 use jf_test_16_mod , only : test_16 use jf_test_17_mod , only : test_17 use jf_test_18_mod , only : test_18 use jf_test_19_mod , only : test_19 use jf_test_20_mod , only : test_20 use jf_test_21_mod , only : test_21 use jf_test_22_mod , only : test_22 use jf_test_23_mod , only : test_23 use jf_test_24_mod , only : test_24 use jf_test_25_mod , only : test_25 use jf_test_26_mod , only : test_26 use jf_test_27_mod , only : test_27 use jf_test_28_mod , only : test_28 use jf_test_29_mod , only : test_29 use jf_test_30_mod , only : test_30 use jf_test_31_mod , only : test_31 use jf_test_32_mod , only : test_32 use jf_test_33_mod , only : test_33 use jf_test_34_mod , only : test_34 use jf_test_35_mod , only : test_35 use jf_test_36_mod , only : test_36 use jf_test_37_mod , only : test_37 use jf_test_38_mod , only : test_38 use jf_test_39_mod , only : test_39 use jf_test_40_mod , only : test_40 use jf_test_41_mod , only : test_41 use jf_test_42_mod , only : test_42 use jf_test_43_mod , only : test_43 use jf_test_44_mod , only : test_44 use jf_test_45_mod , only : test_45 use jf_test_46_mod , only : test_46 use jf_test_47_mod , only : test_47 use jf_test_48_mod , only : test_48 use jf_test_49_mod , only : test_49 implicit none integer :: n_errors !! number of errors n_errors = 0 call test_1 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_2 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_3 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_4 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_5 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_6 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_7 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_8 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_9 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_10 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_11 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_12 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_13 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_14 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_15 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_16 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_17 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_18 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_19 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_20 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_21 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_22 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_23 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_24 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_25 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_26 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_27 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_28 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_29 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_30 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_31 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_32 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_33 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_34 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_35 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_36 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_37 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_38 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_39 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_40 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_41 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_42 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_43 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_44 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_45 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_46 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_47 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_48 ( n_errors ); if ( n_errors /= 0 ) stop 1 call test_49 ( n_errors ); if ( n_errors /= 0 ) stop 1 end program jsonfortrantest !*****************************************************************************************","tags":"","loc":"sourcefile/jsonfortrantest.f90.html"},{"title":"test_iso_10646_support.f90 – Fortran Program","text":"Contents Programs test_iso_10646_support Source Code test_iso_10646_support.f90 Source Code !******************************************************************************************************* !> author: Izaak Beekman ! ! This program is run when configuring the json-fortran build, ! to determine whether or not ISO 10646/UCS4 characters are ! supported by the compiler. program test_iso_10646_support use iso_fortran_env , only : output_unit , error_unit implicit none integer , parameter :: UCS4_K = selected_char_kind ( 'ISO_10646' ) if ( UCS4_K == - 1 ) then !Not supported! write ( error_unit , '(A)' ) 'Your compiler does not support ISO 10646/UCS4 characters!' write ( error_unit , '(A)' ) 'JSON-Fortran must/will be configured to use the \"DEFAULT\"' write ( error_unit , '(A)' ) 'character set. (Should be \"ASCII\" on a reasonable system.)' stop 2 else write ( error_unit , '(A)' ) 'Congratulations! Your compiler supports ISO 10646/UCS4!' write ( error_unit , '(A)' ) 'JSON-Fortran may be configured to enable UCS4 support.' write ( output_unit , '(A)' ) 'UCS4_SUPPORTED' end if end program test_iso_10646_support !*******************************************************************************************************","tags":"","loc":"sourcefile/test_iso_10646_support.f90.html"},{"title":"ftools.f90 – Fortran Program","text":"Contents Modules file_operations Source Code ftools.f90 Source Code module file_operations !! Module to work with files implicit none integer :: out_id !! ID of an output file contains character ( len = 260 ) function outfile_with_id ( str , id ) !!From an output file name and id return a string with the style: !!  <name><id>.txt character ( len = 260 ), intent ( in ) :: str !! Generic name integer , intent ( in ) :: id !! Output file ID character ( len = 50 ) :: id_str write ( id_str , * ) id outfile_with_id = trim ( trim ( str ) // adjustl ( id_str )) // '.txt' end function end module","tags":"","loc":"sourcefile/ftools.f90.html"},{"title":"main.f90 – Fortran Program","text":"Contents Programs main Source Code main.f90 Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"constants.f90 – Fortran Program","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~cubic_eos.f90->sourcefile~mixture.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~cubic_parameter.f90 cubic_parameter.f90 sourcefile~cubic_parameter.f90->sourcefile~constants.f90 sourcefile~rkpr.f90 rkpr.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants implicit none integer , parameter :: wp = 8 real ( wp ), parameter :: RGAS = 0.08314472d0 real ( wp ), parameter :: A0 = 0.0017 , B0 = 1.9681 , C0 = - 2.7238 real ( wp ), parameter :: A1 = - 2.4407 , B1 = 7.4513 , C1 = 1 2.504 real ( wp ), dimension ( 6 ) :: D = [ 0.428363 , 1 8.496215 , 0.338426 , & 0.660 , 78 9.723105 , 2.512392 ] real ( wp ), parameter :: ERRMAX = 1.D-8 end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"cubic_eos.f90 – Fortran Program","text":"This file depends on sourcefile~~cubic_eos.f90~~EfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~cubic_eos.f90->sourcefile~mixture.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixture.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cubic_eos Source Code cubic_eos.f90 Source Code module cubic_eos !! Module that encompass the calculations of the residual Helmholtz energy !! and related properties like fugacity coefficents. use constants implicit none contains subroutine kij_tdep ( T , kij , dkijdt , dkij2dt2 ) !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module use mixture , only : nc , kij_0 , kij_inf , T_star implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: kij ( nc , nc ) !! Binary interaction parameter matrix real ( wp ), intent ( out ) :: dkijdt ( nc , nc ) !! Binary interaction parameter first derivative with T matrix real ( wp ), intent ( out ) :: dkij2dt2 ( nc , nc ) !! Binary interaction parameter second derivative with T matrix integer :: i do i = 1 , nc kij (: i - 1 , i ) = kij_inf (: i - 1 , i ) + kij_0 (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkijdt (: i - 1 , i ) = - kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkij2dt2 (: i - 1 , i ) = kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) ** 2 * exp ( - T / T_star (: i - 1 , i )) end do end subroutine kij_tdep subroutine aTder ( T , a , dadT , dadT2 ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. use mixture , only : nmodel , ac , k , tc , nc real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: a ( nc ) !! Atractive parameter at T real ( wp ), intent ( out ) :: dadT ( nc ) !! First deritvative with T real ( wp ), intent ( out ) :: dadT2 ( nc ) !! Second derivative with T real ( wp ) :: Tr ( nc ) ! Reduced temperature Tr = T / Tc if ( nmodel <= 2 ) then ! SRK and PR a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) else if ( nmodel == 3 ) then ! RKPR EOS a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder subroutine aijTder ( T , aij , daijdT , daij2dT2 ) !! Calculate the binary atractive term matrix use mixture , only : nc , ntdep , kij , kij_0 , lij , ncomb use mixing_rules , only : quadratic implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Atractive binary terms matrix real ( wp ), intent ( out ) :: daijdT ( nc , nc ) !! Atractive binary terms matrix first derivative with temperature real ( wp ), intent ( out ) :: daij2dT2 ( nc , nc ) !! Atractive binary terms matrix second derivative with temperature real ( wp ) :: dkijdt ( nc , nc ), dkij2dt2 ( nc , nc ) ! kij T derivatives real ( wp ) :: a ( nc ), dadT ( nc ), da2dT2 ( nc ) ! Atractive parameter and T derivatives real ( wp ) :: b ( nc ), bij ( nc , nc ) ! Repulsive parameter (just to use as input in subroutine) b = 0 ! Here only the aij for the mixture, so there is no need to use the real b select case ( ntdep ) case ( 1 ) ! Kij exponential temperature dependance call kij_tdep ( T , kij , dkijdt , dkij2dt2 ) case default kij = kij_0 dkijdt = 0 dkij2dt2 = 0 end select ! Calculate pure compound atractive parameters at T call aTder ( T , a , dadT , da2dT2 ) ! Apply combining rule select case ( ncomb ) case default call quadtratic ( a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , & lij , aij , daijdt , daij2dt2 , bij , nc ) end select end subroutine aijTder subroutine DandTnder ( T , rn , D , dDdni , dD2dniT2 , dD2dnij2 , dDdT , dD2dT2 ) use mixture , only : nc real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( in ) :: rn ( nc ) !! ?????? real ( wp ), intent ( out ) :: dDdni ( nc ) !! Density first derivative with number of moles real ( wp ), intent ( out ) :: dD2dniT2 ( nc ) !! Density second derivative with moles and Tempeature real ( wp ), intent ( out ) :: dD2dnij2 ( nc , nc ) !! Density second derivative with number of moles real ( wp ), intent ( out ) :: dDdT ( nc ) !! Density first derivative with Tempeature real ( wp ), intent ( out ) :: dD2dT2 ( nc ) !! Density first derivative with Tempeature real ( wp ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) call aijTder ( T , aij , daijdT , daijdT2 ) D = 0.0D0 dDdT = 0.0D0 dDdT2 = 0.0D0 do i = 1 , nc aux = 0.0D0 aux2 = 0.0D0 dDdni ( i ) = 0.0D0 dD2dniT2 ( i ) = 0.0D0 do j = 1 , nc dDi ( i ) = dDi ( i ) + 2 * rn ( j ) * aij ( i , j ) dDiT ( i ) = dDiT ( i ) + 2 * rn ( j ) * daijdT ( i , j ) dDij ( i , j ) = 2 * aij ( i , j ) aux = aux + rn ( j ) * aij ( i , j ) aux2 = aux2 + rn ( j ) * daijdT2 ( i , j ) end do D = D + rn ( i ) * aux dDdT = dDdT + rn ( i ) * dDiT ( i ) / 2 dDdT2 = dDdT2 + rn ( i ) * aux2 end do end subroutine DandTnder end module cubic_eos","tags":"","loc":"sourcefile/cubic_eos.f90.html"},{"title":"mixture.f90 – Fortran Program","text":"This file depends on sourcefile~~mixture.f90~~EfferentGraph sourcefile~mixture.f90 mixture.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixture.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixture.f90~~AfferentGraph sourcefile~mixture.f90 mixture.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~mixture.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules datatypes mixture Source Code mixture.f90 Source Code module datatypes use constants implicit none type mix integer :: nmodel !! Model to use integer :: nc !! Number of components integer :: ntdep !! Temperature dependence integer :: ncomb !! Combining rule character ( len = :), dimension (:), allocatable :: names !! Components names real ( wp ), dimension (:), allocatable :: n !! Number of moles ! Properties real ( wp ), dimension (:), allocatable :: tc !! Critical Temperatures real ( wp ), dimension (:), allocatable :: pc !! Critical Pressures real ( wp ), dimension (:), allocatable :: dc !! Critical Densities (from EOS) real ( wp ), dimension (:), allocatable :: w !! Accentric factors ! EOS parameters real ( wp ), dimension (:), allocatable :: ac !! EOS atractive parameter real ( wp ), dimension (:), allocatable :: b !! EOS repulsive parameter real ( wp ), dimension (:), allocatable :: del1 !! EOS delta_1 real ( wp ), dimension (:), allocatable :: k !! k parameter to calculate the a parameter ! Mixing parameters real ( wp ), dimension (:, :), allocatable :: kij !! Kij matrix real ( wp ), dimension (:, :), allocatable :: kij0 !! Kij standard real ( wp ), dimension (:, :), allocatable :: kij_inf !! Kij at infinite temperature real ( wp ), dimension (:, :), allocatable :: T_star !! Reference temperature for temperature dependent Kij real ( wp ), dimension (:, :), allocatable :: lij !! lij matrix real ( wp ), dimension (:, :), allocatable :: aij !! EOS atractive parameter matrix end type mix end module datatypes module mixture !! Module to represent a mixture of fluids, it's used to save the !! multiple component's properties to be used by different subroutines. !! It also includes a set of subroutines to read the data and save it !! in the module. !! System of units: !! !! - Volume: Liter !! - Pressure: bar !! - Temperature: Kelvin use constants implicit none integer :: nmodel !! Model to use integer :: nc !! Number of components integer :: ntdep !! Temperature dependence integer :: ncomb !! Combining rule character ( len = :), dimension (:), allocatable :: names !! Components names real ( wp ), dimension (:), allocatable :: n !! Number of moles ! Properties real ( wp ), dimension (:), allocatable :: tc !! Critical Temperatures real ( wp ), dimension (:), allocatable :: pc !! Critical Pressures real ( wp ), dimension (:), allocatable :: dc !! Critical Densities (from EOS) real ( wp ), dimension (:), allocatable :: w !! Accentric factors ! EOS parameters real ( wp ), dimension (:), allocatable :: ac !! EOS atractive parameter real ( wp ), dimension (:), allocatable :: b !! EOS repulsive parameter real ( wp ), dimension (:), allocatable :: del1 !! EOS delta_1 real ( wp ), dimension (:), allocatable :: k !! k parameter to calculate the a parameter ! Mixing parameters real ( wp ), dimension (:, :), allocatable :: kij !! Kij matrix real ( wp ), dimension (:, :), allocatable :: kij_0 !! Kij standard real ( wp ), dimension (:, :), allocatable :: kij_inf !! Kij at infinite temperature real ( wp ), dimension (:, :), allocatable :: T_star !! Reference temperature for temperature dependent Kij real ( wp ), dimension (:, :), allocatable :: lij !! lij matrix real ( wp ), dimension (:, :), allocatable :: aij !! EOS atractive parameter matrix contains subroutine setup ( nin , filename ) !! This subroutine will be used to read data files and get the !! mixture properties integer , intent ( in ) :: nin character ( len = :), allocatable , intent ( in ) :: filename read ( nin , * ) nc read ( nin , * ) nmodel read ( nin , * ) ncomb , ntdep end subroutine setup end module mixture","tags":"","loc":"sourcefile/mixture.f90.html"},{"title":"rkpr.f90 – Fortran Program","text":"This file depends on sourcefile~~rkpr.f90~~EfferentGraph sourcefile~rkpr.f90 rkpr.f90 sourcefile~constants.f90 constants.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rkpr Source Code rkpr.f90 Source Code module rkpr use constants implicit none contains end module rkpr","tags":"","loc":"sourcefile/rkpr.f90.html"},{"title":"mixing_rules.f90 – Fortran Program","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mixing_rules Source Code mixing_rules.f90 Source Code module mixing_rules !! Module that contains the available mixing rules to be used. use constants implicit none contains subroutine quadratic ( a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij , n ) !! Cuadratic Van der Waals mixing rules. implicit none real ( wp ), intent ( in ) :: a ( n ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( n ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( n , n ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( n ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( n ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( n , n ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( n , n ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( n , n ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( n , n ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( n , n ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( n , n ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( n , n ) !! Repulse parameter matrix integer , intent ( in ) :: n integer :: i , j do i = 1 , n aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , n aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic end module mixing_rules","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"cubic_parameter.f90 – Fortran Program","text":"This file depends on sourcefile~~cubic_parameter.f90~~EfferentGraph sourcefile~cubic_parameter.f90 cubic_parameter.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_parameter.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parameters converter Source Code cubic_parameter.f90 Source Code module parameters use iso_fortran_env implicit none real ( 8 ), save :: Tc , dc real ( 8 ), save :: a , b , del1 end module parameters module converter use iso_fortran_env use constants implicit none contains ! ============================================================================= !  Subroutines to obtain EOS parameters from critical constants ! ----------------------------------------------------------------------------- subroutine pr_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc ! Critical temperature real ( 8 ), intent ( in ) :: Pc ! Critical pressure real ( 8 ), intent ( in ) :: w ! Accentric factor real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: ac ! ac parameter real ( 8 ), intent ( out ) :: b ! Covolume real ( 8 ), intent ( out ) :: m ! Constant to calculate a(T) ! Internal varibles real ( 8 ) :: del1 = 1.0d0 + sqrt ( 2.d0 ) ! delta_1 for PR since the parameters are calculated based on the RKPR method real ( 8 ) :: OMa , OMb , Zc , Vceos ! real ( 8 ) :: RT ! R*T product RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc ! m constant to calculate a depending on temperature if ( w <= 0.491 ) then ! m from PR m = 0.37464 + 1.54226 * w - 0.26992 * w ** 2 end if if ( w > 0.491 ) then ! PR78 m = 0.379642 + 1.48503 * w - 0.164423 * w ** 2 + 0.016666 * w ** 3 end if end subroutine pr_params_from_crit subroutine srk_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: Pc real ( 8 ), intent ( out ) :: w real ( 8 ), intent ( in ) :: R real ( 8 ), intent ( out ) :: ac real ( 8 ), intent ( out ) :: b real ( 8 ), intent ( out ) :: m real ( 8 ) :: del1 = 1.0D0 real ( 8 ) :: OMa , OMb , Zc , Vceos real ( 8 ) :: RT RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc m = 0.48 + 1.574 * w - 0.175 * w ** 2 end subroutine srk_params_from_crit subroutine rkpr_params_from_crit ( & Tc , Pc , w , R , ac , b , k , del1 , Vceos , T , Pvdat , RhoLsat & ) !! Get the RKPR EOS parameters from the substance critical properties. ! Input real ( 8 ), intent ( in ) :: Tc !! Critical temperature real ( 8 ), intent ( in ) :: Pc !! Critical pressure real ( 8 ), intent ( in ) :: w !! accentric factor real ( 8 ), intent ( in ) :: R !! Gas constant ! Optional cases where extra specifications are made real ( 8 ), intent ( inout ), optional :: del1 !! delta_1 real ( 8 ), intent ( inout ), optional :: Vceos !! Critical volume at specification real ( 8 ), intent ( in ), optional :: T !! Temperature used to either estimate k or del1 real ( 8 ), intent ( inout ), optional :: Pvdat !! Vapor pressure used to estimate k real ( 8 ), intent ( in ), optional :: RhoLsat !! Saturation density used to estimate del1 !------------------------------------------------------------------------ real ( 8 ), intent ( out ) :: ac !! ac parameter real ( 8 ), intent ( out ) :: b !! covolume real ( 8 ), intent ( out ) :: k !! k to calculate \"a\" with ac and T real ( 8 ) :: OMa , OMb , Zc , RT , del1ini , dc , Tr , & a , Pv , RHOL , RHOV , phiL , delta_k , Pold , oldk , & Trho , RHOld , del1_old , delta_del1 logical :: del1_spec , Pv_spec , rhoL_spec del1_spec = . false . Pv_spec = . false . rhoL_spec = . false . if ( present ( del1 )) then del1_spec = . true . !print *, \"Specified del1\" end if if ( present ( T )) then if ( present ( Pvdat )) then Pv_spec = . true . !print *, \"Specified Pv\" end if end if if ( present ( T )) then if ( present ( RhoLsat )) then rhoL_spec = . true . !print *, \"Specified RhoLsat\" end if end if ! Initialize delta_1 and get the value that statisfies the Zc ! condition ! ----------------------------------------------------------------------- RT = R * Tc if ( present ( Vceos )) then ! Usual specification with Vceos Zc = Pc * Vceos / RT del1ini = D ( 1 ) + D ( 2 ) * ( D ( 3 ) - Zc ) ** D ( 4 ) + D ( 5 ) * ( D ( 3 ) - Zc ) ** D ( 6 ) call getdel1 ( Zc , del1ini , del1 ) end if if ( rhoL_spec ) then Trho = T / Tc del1 = 2.0 ! initial value RHOld = 0.d0 end if ! Calculate the inbetween parameters and finally get ac and b ! ----------------------------------------------------------------------- 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc ! Obtain the k parameter ! ----------------------------------------------------------------------- dc = Pc / Zc / RT Vceos = 1.0d0 / dc ! initial guess for k parameter k = ( A1 * Zc + A0 ) * w ** 2 + ( B1 * Zc + B0 ) * w + ( C1 * Zc + C0 ) a = ac * ( 3 / ( 2 + Tr )) ** k if ( del1_spec ) then Vceos = Zc * RT / Pc end if if ( Pv_spec ) then ! added 29/06/2013 in order to allow for better reproductions of Pv curves Tr = T / Tc else Tr = 0.7d0 Pvdat = Pc * 10 **- ( 1.0d0 + w ) end if ! Find the value of k that fits with the expected Pv call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) if ( Pv > Pvdat ) then delta_k = 0.1 else delta_k = - 0.1 end if do while ( abs ( Pv - Pvdat ) / Pvdat > 0.005 ) Pold = Pv oldk = k k = k + delta_k a = ac * ( 3 / ( 2 + Tr )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) delta_k = - ( Pv - Pvdat ) * ( k - oldk ) / ( Pv - Pold ) end do if ( rhoL_spec ) then ! November 2011 for RKPR specifying T, RHOLsat if ( abs ( Trho - 0.70 ) > 1.d-2 ) then ! get calculated RHOL when Trho is no 0.70 Pvdat = Pc * 10 **- (( 1. / Trho - 1 d0 ) * 7 * ( 1.0D0 + w ) / 3 ) a = ac * ( 3 / ( 2 + Trho )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Trho , Pvdat , Pv , RHOL , RHOV , phiL ) end if if ( RHOld == 0.d0 ) then del1_old = del1 ! condition for the strange case that del1=2 is solution if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) del1 = 2.1 else delta_del1 = - ( RHOL - RhoLsat ) * ( del1 - del1_old ) / ( RHOL - RHOld ) del1_old = del1 del1 = del1 + delta_del1 end if RHOld = RHOL if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) go to 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc end if end subroutine rkpr_params_from_crit ! ============================================================================= ! ========================================================================== !  Subroutines to obtain critical constants from EOS parameters ! -------------------------------------------------------------------------- subroutine pr_critical_from_params ( ac , b , m , R , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0D0 + sqrt ( 2.0 ) real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * R * b ) Pc = OMb * R * Tc / b Vceos = Zc * R * Tc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine pr_critical_from_params subroutine srk_critical_from_params ( ac , b , m , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0d0 real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = - 0.175 be = 1.574 ga = 0.48 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine srk_critical_from_params subroutine rkpr_critical_from_params ( ac , b , del1 , k , Tc , Pc , w , Vceos ) use constants real ( 8 ), intent ( in ) :: ac ! ac parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: del1 ! delta_1 parameter real ( 8 ), intent ( in ) :: k ! k parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! Accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume real ( 8 ) :: Zc , OMa , OMb , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = A1 * Zc + A0 be = B1 * Zc + B0 ga = C1 * Zc + C0 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine rkpr_critical_from_params ! ========================================================================== ! ========================================================================== !  Extra subroutines ! -------------------------------------------------------------------------- subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) real ( 8 ), intent ( in ) :: del1 ! RKPR delta_1 parameter real ( 8 ), intent ( out ) :: Zc ! Critical compressibility factor real ( 8 ), intent ( out ) :: OMa ! real ( 8 ), intent ( out ) :: OMb ! real ( 8 ) :: d1 , y d1 = ( 1.d0 + del1 ** 2.d0 ) / ( 1.d0 + del1 ) y = 1.d0 + ( 2.d0 * ( 1.d0 + del1 )) ** ( 1.0d0 / 3.d0 ) + ( 4.d0 / ( 1.d0 + del1 )) ** ( 1.0d0 / 3 ) OMa = ( 3.d0 * y * y + 3.d0 * y * d1 + d1 ** 2.d0 + d1 - 1.0d0 ) / ( 3.d0 * y + d1 - 1.0d0 ) ** 2.d0 OMb = 1.d0 / ( 3.d0 * y + d1 - 1.0d0 ) Zc = y / ( 3.d0 * y + d1 - 1.0d0 ) end subroutine get_Zc_OMa_OMb subroutine getdel1 ( Zc_in , del1_ini , del1 ) real ( 8 ), intent ( in ) :: Zc_in real ( 8 ), intent ( in ) :: del1_ini real ( 8 ), intent ( out ) :: del1 real ( 8 ) :: d1 , y , del1_old , Zc , Z_old , aux , error = 1.d0 del1 = del1_ini d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Zc = y / ( 3 * y + d1 - 1.0d0 ) del1_old = del1 if ( Zc . gt . Zc_in ) then del1 = 1.01 * del1 else del1 = 0.99 * del1 end if do while ( error >= 1.0d-6 ) d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Z_old = Zc Zc = y / ( 3 * y + d1 - 1.0d0 ) aux = del1 del1 = del1 - ( Zc - Zc_in ) * ( del1 - del1_old ) / ( Zc - Z_old ) del1_old = aux error = abs ( Zc - Zc_in ) end do end subroutine getdel1 recursive subroutine VaporPressure (& a , b , del1 , Tc , dc , Tr , PVini , Pv , RHOL , RHOV , phiL & ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: dc real ( 8 ), intent ( in ) :: Tr real ( 8 ), intent ( in ) :: PVini real ( 8 ), intent ( out ) :: Pv real ( 8 ), intent ( out ) :: RHOL real ( 8 ), intent ( out ) :: RHOV real ( 8 ), intent ( out ) :: phiL real ( 8 ) :: dphi = 0.d0 , P , T , V , phi , phiV , dphiold , Pold , Plast P = PVini T = Tr * Tc do while ( RHOL < 0.9 * dc . or . RHOV > dc ) if ( RHOL < 0.9 * dc ) then P = 1.01 * P else if ( RHOV > dc ) then P = 0.99 * P end if call VCALC ( 1 , a , b , del1 , T , P , V ) RHOL = 1 / V call VCALC ( - 1 , a , b , del1 , T , P , V ) ! SOLVE for vapor density RHOV = 1 / V end do call FUG_CALC ( a , b , del1 , T , P , 1 / RHOL , phi ) phiL = phi call FUG_CALC ( a , b , del1 , T , P , V , phi ) phiV = phi dphiold = dphi dphi = phiV - phiL ! ASK: Is this really a recursion? Plast = P if ( ABS ( dphi ) . gt . ERRMAX ) then Pold = Plast Plast = P if ( dphiold == 0.0D0 . or . Tr . gt . 0.975 ) then P = P * ( phiL / phiV ) else P = Plast - dphi * ( Plast - Pold ) / ( dphi - dphiold ) end if call VaporPressure ( a , b , del1 , Tc , dc , Tr , P , Pv , RHOL , RHOV , phiL ) end if PV = P return end recursive subroutine VCALC ( ITYP , a , b , del1 , T , P , V ) ! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use constants , only : RGAS integer , intent ( in ) :: ITYP ! Type of root desired 1 for liquid -1 for vapor real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( out ) :: V ! Internal variables integer :: ITER logical :: FIRST_RUN real ( 8 ) :: ZETMIN , ZETMAX , ZETA , F , F_V , F_2V , F_N , & PCALC , del , AT , DER , VVAP , AVAP FIRST_RUN = . TRUE . ITER = 0 ZETMIN = 0.D0 ZETMAX = . 99 D0 if ( ITYP . GT . 0 ) then ! Liquid estimate ZETA = . 5 D0 else ! Ideal gas estimate ZETA = MIN (. 5 D0 , b * P / ( RGAS * T )) end if del = 1.d0 do while ( abs ( del ) > 1 d - 10 ) V = b / ZETA ITER = ITER + 1 CALL vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) PCALC = RGAS * T * ( 1 / V - F_V ) if ( PCALC . GT . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = F - LOG ( V ) + V * P / ( T * RGAS ) DER = RGAS * T * ( F_2V + 1.d0 ) / b DEL = - ( PCALC - P ) / DER ZETA = ZETA + MAX ( MIN ( DEL , 0.1d0 ), - 0.1d0 ) if ( ZETA . GT . ZETMAX . OR . ZETA . LT . ZETMIN ) then ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end if end do if ( ITYP == 0 ) then VVAP = V AVAP = AT ! Calculate Liquid volume and It's energy call VCALC ( 1 , a , b , del1 , T , P , V ) call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) AT = F - LOG ( V ) + V * P / ( T * RGAS ) if ( AT . GT . AVAP ) V = VVAP end if end subroutine VCALC subroutine vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) ! CALCULATES THE CONTRIBUTION TO THE RESIDUAL, REDUCED HELMHOLZ ENERGY (F) ! AND ITS FIRST AND SECOND DERIVATIVE WRT V use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T ! Temperature [K] real ( 8 ), intent ( in ) :: V ! Volume: [mL/mol] or [mL] for checking n-derivatives real ( 8 ), intent ( out ) :: F ! A&#94;RES/RT CONTRIBUTION (DIMENSIONLESS) or (MOLES) real ( 8 ), intent ( out ) :: F_V ! 1ST V-DERIVATIVE OF F real ( 8 ), intent ( out ) :: F_2V ! 1ST V-DERIVATIVE OF F_V  (*V**2) real ( 8 ), intent ( out ) :: F_N ! 1ST N-DERIVATIVE OF F real ( 8 ) :: C , aRT , ETA , SUMC , SUMD , REP , ATT , ATTV , REPV , REP2V , ATT2V C = ( 1 - del1 ) / ( 1 + del1 ) aRT = a / ( RGAS * T ) ETA = 0.25 * b / V SUMC = c * b + V SUMD = del1 * b + V REP = - log ( 1 - 4 * ETA ) ATT = aRT * LOG ( SUMD / SUMC ) / ( b * ( C - del1 )) ATTV = aRT / SUMC / SUMD REPV = 1 / ( 1 - 4 * ETA ) - 1 REP2V = 1 / ( 1 - 4 * ETA ) ** 2 - 1 ATT2V = aRT * V ** 2 * ( 1 / SUMD ** 2 - 1 / SUMC ** 2 ) / ( b * ( C - del1 )) F = REP + ATT F_V = ( - REPV / V + ATTV ) F_2V = REP2V - ATT2V F_N = REP + ATT - V * F_V end subroutine FUG_CALC ( a , b , del1 , T , P , V , phi ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( in ) :: V real ( 8 ), intent ( out ) :: phi real ( 8 ) :: RT , Z , F , F_V , F_2V , F_N RT = RGAS * T Z = P * V / RT call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) phi = exp ( F_N ) / Z end ! ========================================================================== end module converter","tags":"","loc":"sourcefile/cubic_parameter.f90.html"},{"title":"build.sh – Fortran Program","text":"/bin/bash */} ###### for debugging echo \"\"\necho \"-------------------\"\necho \"no-unicode file\"\necho \"-------------------\"\ncat -no-unicode.gcov\necho \"\"\necho \"-------------------\"\necho \"unicode file\"\necho \"-------------------\"\ncat -unicode.gcov\necho \"\"\n./pages/development-resources/gccr.pl -n -c -no-unicode.gcov no-unicode \\\n-unicode.gcov unicode Contents Source Code build.sh Source Code #!/bin/bash # #  NAME #    build.sh # #  DESCRIPTION #    Build the JSON-Fortran library and unit tests. # #  USAGE #    build.sh [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>'] #             [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]] #             [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help] #             [--clean] [--real-kind [{REAL32\\REAL64\\REAL128}]] #             [--int-kind [{INT8\\INT16\\INT32\\INT64}]] # #    By default, if invoked without any flags, this build script will build the #    JSON-Fortran library using gfortran, #        without : #            unicode support #            coverage flags #            profiling flags #        with : #            unit tests enabled #            documentation (if FORD is installed) #            real(REAL64) kinds #            integer(INT32) kinds # #     More recent (right-most) flags will override preceding flags #     flags: #        --compiler : gnu or gfortran for gfortran, intel or ifort for intel compiler #                     A custom compiler may also be specified here, e.g. ftn # #        --cflags : Enter any additional/custom compiler flags here and make sure they are #                   properly quoted # #        --help : Print a usage message and exit. # #        --clean : Delete generated files and clean up after builds # # #        The following flags all (optionally) accept an argument, \"yes\" or \"no.\" If #        no argument is passed, \"yes\" will be assumed. # #        --enable-unicode [{yes|no}]: Request that the JSON-Fortran be built with (or #                                     without) unicode/UCS4 support. If your compiler #                                     does NOT support ISO 10646/UCS4 and it was #                                     requested, then a warning is printed and the #                                     library is built without UCS4 support. # #        --coverage [{yes|no}]: Compile the library and tests with code coverage enabled #                               or disabled. # #        --profile [{yes|no}]: Compile the library and tests with code profiling enabled #                              or disabled # #        --skip-tests [{yes|no}]: Skip (or don't skip) building and running the json- #                                 fortran unit tests # #        --skip-documentation [{yes|no}]: Skip (or don't skip) building the json- #                                         fortran documentation using FORD # #  REQUIRES #    FoBiS.py : https://github.com/szaghi/FoBiS                    [version 1.2.5 or later required] #    FORD     : https://github.com/Fortran-FOSS-Programmers/ford   [version 4.0.0 or later] # #  AUTHOR #    Jacob Williams : 12/27/2014 # #set -x #set -v set -o errexit FORDMD = 'json-fortran.md' # FORD options file for building documentation DOCDIR = './doc/' # build directory for documentation PAGESDIR = './pages/' # Directory for FORD \"pages\" SRCDIR = './src/' # library source directory TESTDIR = './src/tests/' # unit test source directory INTROSPECDIR = './src/tests/introspection/' # pre compile configuration tests directory UCS4TESTCODE = 'test_iso_10646_support.f90' BINDIR = './bin/' # build directory for unit tests LIBDIR = './lib/' # build directory for library MODCODE = 'json_module.F90' # json module file name LIBOUT = 'libjsonfortran.a' # name of json library FPP = \"gfortran -E\" # default to gfortran -E pre-processing # The following warning might be triggered by ifort unless explicitly silenced: # warning #7601: F2008 standard does not allow an internal procedure to be an actual argument procedure name. (R1214.4). # In the context of F2008 this is an erroneous warning. # See https://prd1idz.cps.intel.com/en-us/forums/topic/486629 INTELCOMPILERFLAGS = '-c -O2 -warn -stand f08 -diag-disable 7601 -diag-disable 4013 -diag-disable 5142 -traceback' #INTELCOMPILERFLAGS='-c -O2 -warn -traceback -stand f08 -assume protect_parens -assume buffered_io -check all' GNUCOMPILERFLAGS = '-c -O2 -fbacktrace -Wall -Wextra -Wno-maybe-uninitialized -Wno-unused-function -pedantic -std=f2008 -fno-omit-frame-pointer' FCOMPILER = 'gnu' #Set default compiler to gfortran # command line argument parsing # N.B.: Arguments appearing later in the list take precidence over those appearing earlier. #       e.g., \"./build.sh --compiler intel --coverage no --compiler gnu --coverage\" will #       perform the build with the GFORTRAN compiler, and coverage analysis script_name = \" $( basename \" $0 \" ) \" # usage message print_usage () { echo -e \"\\n\\nUsage:\\n\" echo -e \" ${ script_name } [--compiler {intel|gnu|<other>}] [--cflags '<custom compiler flags here>']\\n\\ [--coverage [{yes|no}]] [--profile [{yes|no}]] [--skip-tests [{yes|no}]]\\n\\ [--skip-documentation [{yes|no}]] [--enable-unicode [{yes|no}]] [--help]\" echo \"\" echo -e \"Any flags that take an optional yes or no argument will default to 'yes' when no\\n\\ argument is passed. Additionally, A custom compiler may be passed to the 'compiler'\\n\\ flag, but appropriate 'cflags' should also be passed to the script.\\n\\n\" } while [ \" $# \" -ge \"1\" ] ; do # Get command line arguments while there are more left to process key = \" $1 \" # Command line args are key-value pairs or value-less keys case $key in #find known keys --compiler ) #pick the compiler. Defaults to gfortran, but intel or custom compilers can be used case \" $2 \" in intel | Intel | INTEL | ifort ) FCOMPILER = 'Intel' FCOMPILERFLAGS = \" $INTELCOMPILERFLAGS \" FPP = \"fpp\" shift ;; gnu | Gnu | GNU | gfortran | Gfortran | GFortran | GFORTRAN ) FCOMPILER = 'gnu' FCOMPILERFLAGS = \" $GNUCOMPILERFLAGS \" FPP = \"gfortran -E\" shift ;; * ) FCOMPILER = \"custom\" echo \"Warning: Trying to build with unsupported compiler, $2 .\" 1 > & 2 echo \"Please ensure you set appropriate --cflags and (single) quote them\" 1 > & 2 FC = \" $2 \" FPP = \"gfortran -E\" # try gfortran to preprocess as a default shift ;; esac ;; --cflags ) FCOMPILERFLAGS = \" $2 \" # no good way to check that the user didn't do something questionable shift ;; --real-kind ) REAL_KIND = \"-D $2 \" # warning: not checking for valid input # should be one of: REAL32, REAL64 [default], REAL128 shift ;; --int-kind ) INT_KIND = \"-D $2 \" # warning: not checking for valid input # should be one of: INT8, INT16, INT32 [default], INT64 shift ;; --enable-unicode ) case $2 in yes | Yes | YES ) TRY_UNICODE = \"yes\" shift ;; no | No | NO ) TRY_UNICODE = \"no\" shift ;; * ) TRY_UNICODE = \"yes\" # don't shift; $2 is next arg ;; esac ;; --coverage ) # enable coverage case $2 in yes | Yes | YES ) CODE_COVERAGE = \"yes\" shift ;; no | No | NO ) CODE_COVERAGE = \"no\" shift ;; * ) CODE_COVERAGE = \"yes\" # don't shift because $2 is some other flag ;; esac ;; --profile ) #enable profiling case $2 in yes | Yes | YES ) CODE_PROFILE = \"yes\" shift ;; no | No | NO ) CODE_PROFILE = \"no\" shift ;; * ) CODE_PROFILE = \"yes\" # don't shift because $2 is some other flag ;; esac ;; --skip-tests ) # skip tests case $2 in yes | Yes | YES ) JF_SKIP_TESTS = \"yes\" shift ;; no | No | NO ) JF_SKIP_TESTS = \"no\" shift ;; * ) JF_SKIP_TESTS = \"yes\" ;; esac ;; --skip-documentation ) case $2 in yes | Yes | YES ) JF_SKIP_DOCS = \"yes\" shift ;; no | No | NO ) JF_SKIP_DOCS = \"no\" shift ;; * ) JF_SKIP_DOCS = \"yes\" ;; esac ;; --help ) print_usage exit 0 ;; --clean ) rm -r -- src { ,/tests } /*.o $DOCDIR * $LIBDIR * $BINDIR * *.gcov* ;; * ) echo \"Unknown flag, \\\" $1 \\\", passed to ${ script_name } !\" 2 > & 1 print_usage exit 1 ;; esac shift # look at next argument done # with argument parsing loop # if no compiler selected, then we're defaulting to gnu, and need to check that the cflags are set if [ \" $FCOMPILER \" = 'gnu' ] && [ -z \" $FCOMPILERFLAGS \" ] ; then FCOMPILERFLAGS = \" $GNUCOMPILERFLAGS \" fi if [[ $CODE_COVERAGE == [ yY ] * ]] ; then echo \"Trying to compile with code coverage instrumentation.\" COVERAGE = \"-coverage\" fi if [[ $CODE_PROFILE == [ yY ] * ]] ; then echo \"Trying to compile with code profiling instrumentation.\" PROFILING = \"-profile\" fi if [[ $FCOMPILER == custom ]] ; then echo \"Trying to compile with custom compiler, $FC \" CUSTOM =( \"-fc\" \" $FC \" ) fi if [[ $TRY_UNICODE == [ yY ] * ]] ; then echo \"Trying to compile library with Unicode/UCS4 support\" FoBiS.py build -ch -compiler \" ${ FCOMPILER } \" \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } \" -dbld \" ${ BINDIR } \" -s \" ${ INTROSPECDIR } \" -dmod ./ -dobj ./ -t \" ${ UCS4TESTCODE } \" -o \" ${ UCS4TESTCODE %.f90 } \" -colors if \" ${ BINDIR } / ${ UCS4TESTCODE %.f90 } \" ; then DEFINES = \"-DUSE_UCS4 -Wunused-function\" fi fi #build the stand-alone library: echo \"\" echo \"Building library...\" FoBiS.py build -ch -compiler ${ FCOMPILER } \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } ${ REAL_KIND } ${ INT_KIND } \" ${ COVERAGE } ${ PROFILING } -dbld ${ LIBDIR } -s ${ SRCDIR } -dmod ./ -dobj ./ -t ${ MODCODE } -o ${ LIBOUT } -mklib static -colors #build the unit tests (uses the above library): if [[ $JF_SKIP_TESTS ! = [ yY ] * ]] ; then echo \"\" echo \"Building unit tests...\" # FoBiS.py PR #45 work around [ -d \" $BINDIR \" ] || mkdir \" $BINDIR \" for TEST in \" ${ TESTDIR %/ } \" /jf_test_*. [ fF ] 90 ; do THIS_TEST = ${ TEST ##*/ } echo \"Build ${ THIS_TEST %.[fF]90 } \" FoBiS.py build -ch -compiler ${ FCOMPILER } \" ${ CUSTOM [@] } \" -cflags \" ${ FCOMPILERFLAGS } ${ DEFINES } \" ${ COVERAGE } ${ PROFILING } -dbld \" ${ BINDIR } \" -s \" ${ TESTDIR } \" -i \" ${ LIBDIR } \" -libs \" ${ LIBDIR } / ${ LIBOUT } \" -dmod ./ -dobj ./ -t \" ${ THIS_TEST } \" -o \" ${ THIS_TEST %.[fF]90 } \" -colors done else echo \"Skip building the unit tests since \\$JF_SKIP_TESTS has been set to 'true'.\" fi # Run all the tests unless $JF_SKIP_TESTS echo \"\" if [[ $JF_SKIP_TESTS ! = [ yY ] * ]] ; then echo \"Running tests...\" OLD_IGNORES = \" $GLOBIGNORE \" # run next commands in subshell to avoid `cd -` ( cd \" $BINDIR \" GLOBIGNORE = '*.*' # from: http://stackoverflow.com/questions/7992689/bash-how-to-loop-all-files-in-sorted-order ls jf_test_* | sed 's/&#94;[&#94;0-9]*[0-9]*/\\1 \\2/' | sort -k2,2n | tr -d ' ' | while read TEST ; do # It would be nice to run json output printed to stdout through jsonlint, however, # some tests output more than one json structure and these need to be split echo \"\" echo \"======================================================\" echo \"\" echo \"Running ${ TEST } \" \"./ ${ TEST } \" done ) echo \"\" echo \"======================================================\" GLOBIGNORE = \" $OLD_IGNORES \" if [[ $CODE_COVERAGE = [ yY ] * ]] ; then for SRCFILE in json_string_utilities.F90 json_value_module.F90 json_file_module.F90 ; do [ -f ${ SRCDIR }${ SRCFILE } .gcov ] && rm ${ SRCDIR }${ SRCFILE } .gcov gcov -o $LIBDIR ${ SRCDIR }${ SRCFILE } if [[ $TRY_UNICODE = [ yY ] * ]] ; then # gcov/gfortran bug work around awk -F ':' '{line=\"\"; for(i=2;i<=NF;i++){line=line\":\"$i}; if (NR > 1) print $1 prevline; prevline=line}; END{print \"        -\"prevline}' ${ SRCFILE } .gcov > ${ SRCFILE } .gcov.fixed && \\ mv ${ SRCFILE } .gcov { .fixed, } # rename so we can merge coverage info mv ${ SRCFILE } .gcov ${ SRCFILE } -unicode.gcov else # rename so we can merge coverage info mv ${ SRCFILE } .gcov ${ SRCFILE } -no-unicode.gcov fi if [ -f ${ SRCFILE } -unicode.gcov ] && [ -f ${ SRCFILE } -no-unicode.gcov ] ; then ############## for debugging #echo \"\" #echo \"-------------------\" #echo \"no-unicode file\" #echo \"-------------------\" #cat ${SRCFILE}-no-unicode.gcov #echo \"\" #echo \"-------------------\" #echo \"unicode file\" #echo \"-------------------\" #cat ${SRCFILE}-unicode.gcov #echo \"\" #./pages/development-resources/gccr.pl -n -c ${SRCFILE}-no-unicode.gcov no-unicode \\ #                  ${SRCFILE}-unicode.gcov unicode ############## # merge them ./pages/development-resources/gccr.pl -n -c ${ SRCFILE } -no-unicode.gcov no-unicode \\ ${ SRCFILE } -unicode.gcov unicode > ${ SRCFILE } .gcov else cp ${ SRCFILE } *-unicode.gcov ${ SRCFILE } .gcov fi done FoBiS.py rule -gcov_analyzer . for SRCFILE in json_string_utilities.F90 json_value_module.F90 json_file_module.F90 ; do sed -i \"bak\" -E 's; \\*\\*([a-zA-Z]+[a-zA-Z0-9_]*)\\*\\*; \\*\\*[[\\1]]\\*\\*;' ${ SRCFILE } .gcov.md sed -i \"bak\" -E \"s;, line ([0-9]+);, line [\\1](https://github.com/jacobwilliams/json-fortran/blob/master/src/ ${ SRCFILE } #L\\1);\" ${ SRCFILE } .gcov.md done gcov -o $BINDIR ${ TESTDIR } *. [ Ff ] 90 fi else echo \"Skip running the unit tests since \\$JF_SKIP_TESTS has been set to ${ JF_SKIP_TESTS } .\" fi #build the documentation with ford (if present): echo \"\" if [[ $JF_SKIP_DOCS ! = [ yY ] * ]] ; then if hash ford 2 >/dev/null ; then echo \"Building documentation...\" [[ $TRY_UNICODE = [ yY ] * ]] && MACRO_FLAG =( \"-m\" \"USE_UCS4\" ) echo \" $FPP \" > .PREPROCESSOR # Override via include in project file, until FORD gets CLI for this ford --debug \" ${ MACRO_FLAG [@] } \" -p \" $PAGESDIR \" \" $FORDMD \" else echo \"FORD not found! Install using: pip install ford\" fi else echo \"Skip building documentation since \\$JF_SKIP_DOCS has been set to ${ JF_SKIP_DOCS } .\" fi","tags":"","loc":"sourcefile/build.sh.html"},{"title":"mix – Fortran Program ","text":"type, public :: mix Contents Variables nmodel nc ntdep ncomb names n tc pc dc w ac b del1 k kij kij0 kij_inf T_star lij aij Components Type Visibility Attributes Name Initial integer, public :: nmodel Model to use integer, public :: nc Number of components integer, public :: ntdep Temperature dependence integer, public :: ncomb Combining rule character(len=:), public, dimension(:), allocatable :: names Components names real(kind=wp), public, dimension(:), allocatable :: n Number of moles real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: w Accentric factors real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix","tags":"","loc":"type/mix.html"},{"title":"outfile_with_id – Fortran Program","text":"public function outfile_with_id(str, id) From an output file name and id return a string with the style: .txt Arguments Type Intent Optional Attributes Name character(len=260), intent(in) :: str Generic name integer, intent(in) :: id Output file ID Return Value character(len=260) Contents None","tags":"","loc":"proc/outfile_with_id.html"},{"title":"kij_tdep – Fortran Program","text":"public subroutine kij_tdep(T, kij, dkijdt, dkij2dt2) Uses mixture proc~~kij_tdep~~UsesGraph proc~kij_tdep kij_tdep module~mixture mixture proc~kij_tdep->module~mixture module~constants constants module~mixture->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: kij (nc,nc) Binary interaction parameter matrix real(kind=wp), intent(out) :: dkijdt (nc,nc) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out) :: dkij2dt2 (nc,nc) Binary interaction parameter second derivative with T matrix Called by proc~~kij_tdep~~CalledByGraph proc~kij_tdep kij_tdep proc~aijtder aijTder proc~aijtder->proc~kij_tdep proc~dandtnder DandTnder proc~dandtnder->proc~aijtder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kij_tdep.html"},{"title":"aTder – Fortran Program","text":"public subroutine aTder(T, a, dadT, dadT2) Uses mixture proc~~atder~~UsesGraph proc~atder aTder module~mixture mixture proc~atder->module~mixture module~constants constants module~mixture->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture's model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: a (nc) Atractive parameter at T real(kind=wp), intent(out) :: dadT (nc) First deritvative with T real(kind=wp), intent(out) :: dadT2 (nc) Second derivative with T Called by proc~~atder~~CalledByGraph proc~atder aTder proc~aijtder aijTder proc~aijtder->proc~atder proc~dandtnder DandTnder proc~dandtnder->proc~aijtder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/atder.html"},{"title":"aijTder – Fortran Program","text":"public subroutine aijTder(T, aij, daijdT, daij2dT2) Uses mixing_rules mixture proc~~aijtder~~UsesGraph proc~aijtder aijTder module~mixing_rules mixing_rules proc~aijtder->module~mixing_rules module~mixture mixture proc~aijtder->module~mixture module~constants constants module~mixing_rules->module~constants module~mixture->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculate the binary atractive term matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: aij (nc,nc) Atractive binary terms matrix real(kind=wp), intent(out) :: daijdT (nc,nc) Atractive binary terms matrix first derivative with temperature real(kind=wp), intent(out) :: daij2dT2 (nc,nc) Atractive binary terms matrix second derivative with temperature Calls proc~~aijtder~~CallsGraph proc~aijtder aijTder quadtratic quadtratic proc~aijtder->quadtratic proc~kij_tdep kij_tdep proc~aijtder->proc~kij_tdep proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aijtder~~CalledByGraph proc~aijtder aijTder proc~dandtnder DandTnder proc~dandtnder->proc~aijtder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aijtder.html"},{"title":"DandTnder – Fortran Program","text":"public subroutine DandTnder(T, rn, D, dDdni, dD2dniT2, dD2dnij2, dDdT, dD2dT2) Uses mixture proc~~dandtnder~~UsesGraph proc~dandtnder DandTnder module~mixture mixture proc~dandtnder->module~mixture module~constants constants module~mixture->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(in) :: rn (nc) ?????? real :: D real(kind=wp), intent(out) :: dDdni (nc) Density first derivative with number of moles real(kind=wp), intent(out) :: dD2dniT2 (nc) Density second derivative with moles and Tempeature real(kind=wp), intent(out) :: dD2dnij2 (nc,nc) Density second derivative with number of moles real(kind=wp), intent(out) :: dDdT (nc) Density first derivative with Tempeature real(kind=wp), intent(out) :: dD2dT2 (nc) Density first derivative with Tempeature Calls proc~~dandtnder~~CallsGraph proc~dandtnder DandTnder ddij ddij proc~dandtnder->ddij ddi ddi proc~dandtnder->ddi proc~aijtder aijTder proc~dandtnder->proc~aijtder ddit ddit proc~dandtnder->ddit quadtratic quadtratic proc~aijtder->quadtratic proc~kij_tdep kij_tdep proc~aijtder->proc~kij_tdep proc~atder aTder proc~aijtder->proc~atder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dandtnder.html"},{"title":"setup – Fortran Program","text":"public subroutine setup(nin, filename) This subroutine will be used to read data files and get the\nmixture properties Arguments Type Intent Optional Attributes Name integer, intent(in) :: nin character(len=:), intent(in), allocatable :: filename Contents None","tags":"","loc":"proc/setup.html"},{"title":"quadratic – Fortran Program","text":"public subroutine quadratic(a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij, n) Cuadratic Van der Waals mixing rules. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (n) Repulsive parameter real(kind=wp), intent(in) :: kij (n,n) Kij matrix real(kind=wp), intent(in) :: dadt (n) First derivative with T real(kind=wp), intent(in) :: da2dt2 (n) Second derivative with T real(kind=wp), intent(in) :: dkijdt (n,n) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (n,n) Kij matrix second derivative real(kind=wp), intent(in) :: lij (n,n) Lij matrix real(kind=wp), intent(out) :: aij (n,n) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (n,n) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (n,n) Second derivative with T real(kind=wp), intent(out) :: bij (n,n) Repulse parameter matrix integer, intent(in) :: n Contents None","tags":"","loc":"proc/quadratic.html"},{"title":"pr_params_from_crit – Fortran Program","text":"public subroutine pr_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Calls proc~~pr_params_from_crit~~CallsGraph proc~pr_params_from_crit pr_params_from_crit proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr_params_from_crit->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pr_params_from_crit.html"},{"title":"srk_params_from_crit – Fortran Program","text":"public subroutine srk_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Calls proc~~srk_params_from_crit~~CallsGraph proc~srk_params_from_crit srk_params_from_crit proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_params_from_crit->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/srk_params_from_crit.html"},{"title":"rkpr_params_from_crit – Fortran Program","text":"public subroutine rkpr_params_from_crit(Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate \"a\" with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 Calls proc~~rkpr_params_from_crit~~CallsGraph proc~rkpr_params_from_crit rkpr_params_from_crit d d proc~rkpr_params_from_crit->d proc~get_zc_oma_omb get_Zc_OMa_OMb proc~rkpr_params_from_crit->proc~get_zc_oma_omb proc~getdel1 getdel1 proc~rkpr_params_from_crit->proc~getdel1 proc~vaporpressure VaporPressure proc~rkpr_params_from_crit->proc~vaporpressure proc~vaporpressure->proc~vaporpressure proc~fug_calc FUG_CALC proc~vaporpressure->proc~fug_calc proc~vcalc VCALC proc~vaporpressure->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rkpr_params_from_crit.html"},{"title":"pr_critical_from_params – Fortran Program","text":"public subroutine pr_critical_from_params(ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~pr_critical_from_params~~CallsGraph proc~pr_critical_from_params pr_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/pr_critical_from_params.html"},{"title":"srk_critical_from_params – Fortran Program","text":"public subroutine srk_critical_from_params(ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~srk_critical_from_params~~CallsGraph proc~srk_critical_from_params srk_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/srk_critical_from_params.html"},{"title":"rkpr_critical_from_params – Fortran Program","text":"public subroutine rkpr_critical_from_params(ac, b, del1, k, Tc, Pc, w, Vceos) Uses constants proc~~rkpr_critical_from_params~~UsesGraph proc~rkpr_critical_from_params rkpr_critical_from_params module~constants constants proc~rkpr_critical_from_params->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~rkpr_critical_from_params~~CallsGraph proc~rkpr_critical_from_params rkpr_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~rkpr_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rkpr_critical_from_params.html"},{"title":"get_Zc_OMa_OMb – Fortran Program","text":"public subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb Called by proc~~get_zc_oma_omb~~CalledByGraph proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_params_from_crit srk_params_from_crit proc~srk_params_from_crit->proc~get_zc_oma_omb proc~srk_critical_from_params srk_critical_from_params proc~srk_critical_from_params->proc~get_zc_oma_omb proc~rkpr_critical_from_params rkpr_critical_from_params proc~rkpr_critical_from_params->proc~get_zc_oma_omb proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~get_zc_oma_omb proc~pr_critical_from_params pr_critical_from_params proc~pr_critical_from_params->proc~get_zc_oma_omb proc~pr_params_from_crit pr_params_from_crit proc~pr_params_from_crit->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_zc_oma_omb.html"},{"title":"getdel1 – Fortran Program","text":"public subroutine getdel1(Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 Called by proc~~getdel1~~CalledByGraph proc~getdel1 getdel1 proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~getdel1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/getdel1.html"},{"title":"VaporPressure – Fortran Program","text":"public recursive subroutine VaporPressure(a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Uses constants proc~~vaporpressure~~UsesGraph proc~vaporpressure VaporPressure module~constants constants proc~vaporpressure->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL Calls proc~~vaporpressure~~CallsGraph proc~vaporpressure VaporPressure proc~vaporpressure->proc~vaporpressure proc~fug_calc FUG_CALC proc~vaporpressure->proc~fug_calc proc~vcalc VCALC proc~vaporpressure->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vaporpressure~~CalledByGraph proc~vaporpressure VaporPressure proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vaporpressure.html"},{"title":"VCALC – Fortran Program","text":"public recursive subroutine VCALC(ITYP, a, b, del1, T, P, V) Uses constants proc~~vcalc~~UsesGraph proc~vcalc VCALC module~constants constants proc~vcalc->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V Calls proc~~vcalc~~CallsGraph proc~vcalc VCALC proc~vcalc->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vcalc~~CalledByGraph proc~vcalc VCALC proc~vcalc->proc~vcalc proc~vaporpressure VaporPressure proc~vaporpressure->proc~vcalc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vcalc.html"},{"title":"vdWg_Derivs – Fortran Program","text":"public subroutine vdWg_Derivs(a, b, del1, T, V, F, F_V, F_2V, F_N) Uses constants proc~~vdwg_derivs~~UsesGraph proc~vdwg_derivs vdWg_Derivs module~constants constants proc~vdwg_derivs->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N Called by proc~~vdwg_derivs~~CalledByGraph proc~vdwg_derivs vdWg_Derivs proc~fug_calc FUG_CALC proc~fug_calc->proc~vdwg_derivs proc~vcalc VCALC proc~vcalc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vaporpressure VaporPressure proc~vaporpressure->proc~fug_calc proc~vaporpressure->proc~vcalc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vdwg_derivs.html"},{"title":"FUG_CALC – Fortran Program","text":"public subroutine FUG_CALC(a, b, del1, T, P, V, phi) Uses constants proc~~fug_calc~~UsesGraph proc~fug_calc FUG_CALC module~constants constants proc~fug_calc->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi Calls proc~~fug_calc~~CallsGraph proc~fug_calc FUG_CALC proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fug_calc~~CalledByGraph proc~fug_calc FUG_CALC proc~vaporpressure VaporPressure proc~vaporpressure->proc~fug_calc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fug_calc.html"},{"title":"file_operations – Fortran Program","text":"Module to work with files Contents Variables out_id Functions outfile_with_id Variables Type Visibility Attributes Name Initial integer, public :: out_id ID of an output file Functions public function outfile_with_id (str, id) From an output file name and id return a string with the style: .txt Arguments Type Intent Optional Attributes Name character(len=260), intent(in) :: str Generic name integer, intent(in) :: id Output file ID Return Value character(len=260)","tags":"","loc":"module/file_operations.html"},{"title":"constants – Fortran Program","text":"Used by module~~constants~~UsedByGraph module~constants constants module~converter converter module~converter->module~constants proc~rkpr_critical_from_params rkpr_critical_from_params proc~rkpr_critical_from_params->module~constants module~datatypes datatypes module~datatypes->module~constants proc~vaporpressure VaporPressure proc~vaporpressure->module~constants proc~vdwg_derivs vdWg_Derivs proc~vdwg_derivs->module~constants module~mixture mixture module~mixture->module~constants module~cubic_eos cubic_eos module~cubic_eos->module~constants module~rkpr rkpr module~rkpr->module~constants module~mixing_rules mixing_rules module~mixing_rules->module~constants proc~fug_calc FUG_CALC proc~fug_calc->module~constants proc~vcalc VCALC proc~vcalc->module~constants proc~dandtnder DandTnder proc~dandtnder->module~mixture proc~kij_tdep kij_tdep proc~kij_tdep->module~mixture proc~atder aTder proc~atder->module~mixture proc~aijtder aijTder proc~aijtder->module~mixture proc~aijtder->module~mixing_rules Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp RGAS A0 B0 C0 A1 B1 C1 D ERRMAX Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = 8 real(kind=wp), public, parameter :: RGAS = 0.08314472d0 real(kind=wp), public, parameter :: A0 = 0.0017 real(kind=wp), public, parameter :: B0 = 1.9681 real(kind=wp), public, parameter :: C0 = -2.7238 real(kind=wp), public, parameter :: A1 = -2.4407 real(kind=wp), public, parameter :: B1 = 7.4513 real(kind=wp), public, parameter :: C1 = 12.504 real(kind=wp), public, dimension(6) :: D = [0.428363, 18.496215, 0.338426, 0.660, 789.723105, 2.512392] real(kind=wp), public, parameter :: ERRMAX = 1.D-8","tags":"","loc":"module/constants.html"},{"title":"cubic_eos – Fortran Program","text":"Module that encompass the calculations of the residual Helmholtz energy\nand related properties like fugacity coefficents. Uses constants module~~cubic_eos~~UsesGraph module~cubic_eos cubic_eos module~constants constants module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines kij_tdep aTder aijTder DandTnder Subroutines public subroutine kij_tdep (T, kij, dkijdt, dkij2dt2) Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: kij (nc,nc) Binary interaction parameter matrix real(kind=wp), intent(out) :: dkijdt (nc,nc) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out) :: dkij2dt2 (nc,nc) Binary interaction parameter second derivative with T matrix public subroutine aTder (T, a, dadT, dadT2) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture's model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: a (nc) Atractive parameter at T real(kind=wp), intent(out) :: dadT (nc) First deritvative with T real(kind=wp), intent(out) :: dadT2 (nc) Second derivative with T public subroutine aijTder (T, aij, daijdT, daij2dT2) Calculate the binary atractive term matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: aij (nc,nc) Atractive binary terms matrix real(kind=wp), intent(out) :: daijdT (nc,nc) Atractive binary terms matrix first derivative with temperature real(kind=wp), intent(out) :: daij2dT2 (nc,nc) Atractive binary terms matrix second derivative with temperature public subroutine DandTnder (T, rn, D, dDdni, dD2dniT2, dD2dnij2, dDdT, dD2dT2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(in) :: rn (nc) ?????? real :: D real(kind=wp), intent(out) :: dDdni (nc) Density first derivative with number of moles real(kind=wp), intent(out) :: dD2dniT2 (nc) Density second derivative with moles and Tempeature real(kind=wp), intent(out) :: dD2dnij2 (nc,nc) Density second derivative with number of moles real(kind=wp), intent(out) :: dDdT (nc) Density first derivative with Tempeature real(kind=wp), intent(out) :: dD2dT2 (nc) Density first derivative with Tempeature","tags":"","loc":"module/cubic_eos.html"},{"title":"datatypes – Fortran Program","text":"Uses constants module~~datatypes~~UsesGraph module~datatypes datatypes module~constants constants module~datatypes->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types mix Derived Types type, public :: mix Components Type Visibility Attributes Name Initial integer, public :: nmodel Model to use integer, public :: nc Number of components integer, public :: ntdep Temperature dependence integer, public :: ncomb Combining rule character(len=:), public, dimension(:), allocatable :: names Components names real(kind=wp), public, dimension(:), allocatable :: n Number of moles real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: w Accentric factors real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix","tags":"","loc":"module/datatypes.html"},{"title":"mixture – Fortran Program","text":"Module to represent a mixture of fluids, it's used to save the \nmultiple component's properties to be used by different subroutines.\nIt also includes a set of subroutines to read the data and save it\nin the module. System of units: Volume: Liter Pressure: bar Temperature: Kelvin Uses constants module~~mixture~~UsesGraph module~mixture mixture module~constants constants module~mixture->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mixture~~UsedByGraph module~mixture mixture proc~dandtnder DandTnder proc~dandtnder->module~mixture proc~kij_tdep kij_tdep proc~kij_tdep->module~mixture proc~atder aTder proc~atder->module~mixture proc~aijtder aijTder proc~aijtder->module~mixture Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables nmodel nc ntdep ncomb names n tc pc dc w ac b del1 k kij kij_0 kij_inf T_star lij aij Subroutines setup Variables Type Visibility Attributes Name Initial integer, public :: nmodel Model to use integer, public :: nc Number of components integer, public :: ntdep Temperature dependence integer, public :: ncomb Combining rule character(len=:), public, dimension(:), allocatable :: names Components names real(kind=wp), public, dimension(:), allocatable :: n Number of moles real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: w Accentric factors real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij_0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix Subroutines public subroutine setup (nin, filename) This subroutine will be used to read data files and get the\nmixture properties Arguments Type Intent Optional Attributes Name integer, intent(in) :: nin character(len=:), intent(in), allocatable :: filename","tags":"","loc":"module/mixture.html"},{"title":"rkpr – Fortran Program","text":"Uses constants module~~rkpr~~UsesGraph module~rkpr rkpr module~constants constants module~rkpr->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/rkpr.html"},{"title":"mixing_rules – Fortran Program","text":"Module that contains the available mixing rules to be used. Uses constants module~~mixing_rules~~UsesGraph module~mixing_rules mixing_rules module~constants constants module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mixing_rules~~UsedByGraph module~mixing_rules mixing_rules proc~aijtder aijTder proc~aijtder->module~mixing_rules Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines quadratic Subroutines public subroutine quadratic (a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij, n) Cuadratic Van der Waals mixing rules. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (n) Repulsive parameter real(kind=wp), intent(in) :: kij (n,n) Kij matrix real(kind=wp), intent(in) :: dadt (n) First derivative with T real(kind=wp), intent(in) :: da2dt2 (n) Second derivative with T real(kind=wp), intent(in) :: dkijdt (n,n) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (n,n) Kij matrix second derivative real(kind=wp), intent(in) :: lij (n,n) Lij matrix real(kind=wp), intent(out) :: aij (n,n) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (n,n) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (n,n) Second derivative with T real(kind=wp), intent(out) :: bij (n,n) Repulse parameter matrix integer, intent(in) :: n","tags":"","loc":"module/mixing_rules.html"},{"title":"parameters – Fortran Program","text":"Uses iso_fortran_env module~~parameters~~UsesGraph module~parameters parameters iso_fortran_env iso_fortran_env module~parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Tc dc a b del1 Variables Type Visibility Attributes Name Initial real(kind=8), public, save :: Tc real(kind=8), public, save :: dc real(kind=8), public, save :: a real(kind=8), public, save :: b real(kind=8), public, save :: del1","tags":"","loc":"module/parameters.html"},{"title":"converter – Fortran Program","text":"Uses iso_fortran_env constants module~~converter~~UsesGraph module~converter converter module~constants constants module~converter->module~constants iso_fortran_env iso_fortran_env module~converter->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pr_params_from_crit srk_params_from_crit rkpr_params_from_crit pr_critical_from_params srk_critical_from_params rkpr_critical_from_params get_Zc_OMa_OMb getdel1 VaporPressure VCALC vdWg_Derivs FUG_CALC Subroutines public subroutine pr_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine srk_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine rkpr_params_from_crit (Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate \"a\" with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 public subroutine pr_critical_from_params (ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine srk_critical_from_params (ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine rkpr_critical_from_params (ac, b, del1, k, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb public subroutine getdel1 (Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 public recursive subroutine VaporPressure (a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL public recursive subroutine VCALC (ITYP, a, b, del1, T, P, V) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V public subroutine vdWg_Derivs (a, b, del1, T, V, F, F_V, F_2V, F_N) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N public subroutine FUG_CALC (a, b, del1, T, P, V, phi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi","tags":"","loc":"module/converter.html"},{"title":"jsonfortrantest – Fortran Program","text":"Uses jf_test_44_mod jf_test_33_mod jf_test_48_mod jf_test_17_mod jf_test_43_mod jf_test_49_mod jf_test_30_mod jf_test_13_mod jf_test_47_mod jf_test_6_mod jf_test_9_mod jf_test_27_mod jf_test_32_mod jf_test_38_mod jf_test_29_mod jf_test_45_mod jf_test_8_mod jf_test_4_mod jf_test_35_mod jf_test_10_mod jf_test_40_mod jf_test_14_mod jf_test_37_mod jf_test_11_mod jf_test_24_mod jf_test_25_mod jf_test_39_mod jf_test_46_mod jf_test_42_mod jf_test_36_mod jf_test_26_mod jf_test_3_mod jf_test_34_mod jf_test_19_mod jf_test_18_mod jf_test_1_mod jf_test_41_mod jf_test_23_mod jf_test_28_mod jf_test_20_mod jf_test_12_mod jf_test_21_mod jf_test_7_mod jf_test_16_mod jf_test_22_mod jf_test_15_mod jf_test_5_mod jf_test_31_mod jf_test_2_mod program~~jsonfortrantest~~UsesGraph program~jsonfortrantest jsonfortrantest jf_test_44_mod jf_test_44_mod program~jsonfortrantest->jf_test_44_mod jf_test_48_mod jf_test_48_mod program~jsonfortrantest->jf_test_48_mod jf_test_33_mod jf_test_33_mod program~jsonfortrantest->jf_test_33_mod jf_test_17_mod jf_test_17_mod program~jsonfortrantest->jf_test_17_mod jf_test_43_mod jf_test_43_mod program~jsonfortrantest->jf_test_43_mod jf_test_49_mod jf_test_49_mod program~jsonfortrantest->jf_test_49_mod jf_test_30_mod jf_test_30_mod program~jsonfortrantest->jf_test_30_mod jf_test_13_mod jf_test_13_mod program~jsonfortrantest->jf_test_13_mod jf_test_47_mod jf_test_47_mod program~jsonfortrantest->jf_test_47_mod jf_test_6_mod jf_test_6_mod program~jsonfortrantest->jf_test_6_mod jf_test_9_mod jf_test_9_mod program~jsonfortrantest->jf_test_9_mod jf_test_27_mod jf_test_27_mod program~jsonfortrantest->jf_test_27_mod jf_test_32_mod jf_test_32_mod program~jsonfortrantest->jf_test_32_mod jf_test_38_mod jf_test_38_mod program~jsonfortrantest->jf_test_38_mod jf_test_29_mod jf_test_29_mod program~jsonfortrantest->jf_test_29_mod jf_test_45_mod jf_test_45_mod program~jsonfortrantest->jf_test_45_mod jf_test_8_mod jf_test_8_mod program~jsonfortrantest->jf_test_8_mod jf_test_4_mod jf_test_4_mod program~jsonfortrantest->jf_test_4_mod jf_test_35_mod jf_test_35_mod program~jsonfortrantest->jf_test_35_mod jf_test_10_mod jf_test_10_mod program~jsonfortrantest->jf_test_10_mod jf_test_40_mod jf_test_40_mod program~jsonfortrantest->jf_test_40_mod jf_test_14_mod jf_test_14_mod program~jsonfortrantest->jf_test_14_mod jf_test_37_mod jf_test_37_mod program~jsonfortrantest->jf_test_37_mod jf_test_11_mod jf_test_11_mod program~jsonfortrantest->jf_test_11_mod jf_test_24_mod jf_test_24_mod program~jsonfortrantest->jf_test_24_mod jf_test_25_mod jf_test_25_mod program~jsonfortrantest->jf_test_25_mod jf_test_39_mod jf_test_39_mod program~jsonfortrantest->jf_test_39_mod jf_test_46_mod jf_test_46_mod program~jsonfortrantest->jf_test_46_mod jf_test_42_mod jf_test_42_mod program~jsonfortrantest->jf_test_42_mod jf_test_36_mod jf_test_36_mod program~jsonfortrantest->jf_test_36_mod jf_test_26_mod jf_test_26_mod program~jsonfortrantest->jf_test_26_mod jf_test_3_mod jf_test_3_mod program~jsonfortrantest->jf_test_3_mod jf_test_34_mod jf_test_34_mod program~jsonfortrantest->jf_test_34_mod jf_test_19_mod jf_test_19_mod program~jsonfortrantest->jf_test_19_mod jf_test_18_mod jf_test_18_mod program~jsonfortrantest->jf_test_18_mod jf_test_1_mod jf_test_1_mod program~jsonfortrantest->jf_test_1_mod jf_test_41_mod jf_test_41_mod program~jsonfortrantest->jf_test_41_mod jf_test_23_mod jf_test_23_mod program~jsonfortrantest->jf_test_23_mod jf_test_28_mod jf_test_28_mod program~jsonfortrantest->jf_test_28_mod jf_test_20_mod jf_test_20_mod program~jsonfortrantest->jf_test_20_mod jf_test_12_mod jf_test_12_mod program~jsonfortrantest->jf_test_12_mod jf_test_21_mod jf_test_21_mod program~jsonfortrantest->jf_test_21_mod jf_test_7_mod jf_test_7_mod program~jsonfortrantest->jf_test_7_mod jf_test_16_mod jf_test_16_mod program~jsonfortrantest->jf_test_16_mod jf_test_22_mod jf_test_22_mod program~jsonfortrantest->jf_test_22_mod jf_test_15_mod jf_test_15_mod program~jsonfortrantest->jf_test_15_mod jf_test_5_mod jf_test_5_mod program~jsonfortrantest->jf_test_5_mod jf_test_31_mod jf_test_31_mod program~jsonfortrantest->jf_test_31_mod jf_test_2_mod jf_test_2_mod program~jsonfortrantest->jf_test_2_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~jsonfortrantest~~CallsGraph program~jsonfortrantest jsonfortrantest test_14 test_14 program~jsonfortrantest->test_14 test_15 test_15 program~jsonfortrantest->test_15 test_27 test_27 program~jsonfortrantest->test_27 test_20 test_20 program~jsonfortrantest->test_20 test_1 test_1 program~jsonfortrantest->test_1 test_4 test_4 program~jsonfortrantest->test_4 test_39 test_39 program~jsonfortrantest->test_39 test_37 test_37 program~jsonfortrantest->test_37 test_19 test_19 program~jsonfortrantest->test_19 test_12 test_12 program~jsonfortrantest->test_12 test_26 test_26 program~jsonfortrantest->test_26 test_31 test_31 program~jsonfortrantest->test_31 test_3 test_3 program~jsonfortrantest->test_3 test_6 test_6 program~jsonfortrantest->test_6 test_35 test_35 program~jsonfortrantest->test_35 test_7 test_7 program~jsonfortrantest->test_7 test_17 test_17 program~jsonfortrantest->test_17 test_8 test_8 program~jsonfortrantest->test_8 test_13 test_13 program~jsonfortrantest->test_13 test_21 test_21 program~jsonfortrantest->test_21 test_11 test_11 program~jsonfortrantest->test_11 test_28 test_28 program~jsonfortrantest->test_28 test_32 test_32 program~jsonfortrantest->test_32 test_45 test_45 program~jsonfortrantest->test_45 test_38 test_38 program~jsonfortrantest->test_38 test_33 test_33 program~jsonfortrantest->test_33 test_9 test_9 program~jsonfortrantest->test_9 test_23 test_23 program~jsonfortrantest->test_23 test_5 test_5 program~jsonfortrantest->test_5 test_48 test_48 program~jsonfortrantest->test_48 test_49 test_49 program~jsonfortrantest->test_49 test_36 test_36 program~jsonfortrantest->test_36 test_44 test_44 program~jsonfortrantest->test_44 test_24 test_24 program~jsonfortrantest->test_24 test_2 test_2 program~jsonfortrantest->test_2 test_34 test_34 program~jsonfortrantest->test_34 test_46 test_46 program~jsonfortrantest->test_46 test_22 test_22 program~jsonfortrantest->test_22 test_47 test_47 program~jsonfortrantest->test_47 test_30 test_30 program~jsonfortrantest->test_30 test_42 test_42 program~jsonfortrantest->test_42 test_40 test_40 program~jsonfortrantest->test_40 test_18 test_18 program~jsonfortrantest->test_18 test_41 test_41 program~jsonfortrantest->test_41 test_25 test_25 program~jsonfortrantest->test_25 test_16 test_16 program~jsonfortrantest->test_16 test_29 test_29 program~jsonfortrantest->test_29 test_43 test_43 program~jsonfortrantest->test_43 test_10 test_10 program~jsonfortrantest->test_10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n_errors Variables Type Attributes Name Initial integer :: n_errors number of errors","tags":"","loc":"program/jsonfortrantest.html"},{"title":"test_iso_10646_support – Fortran Program","text":"Uses iso_fortran_env program~~test_iso_10646_support~~UsesGraph program~test_iso_10646_support test_iso_10646_support iso_fortran_env iso_fortran_env program~test_iso_10646_support->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables UCS4_K Variables Type Attributes Name Initial integer, parameter :: UCS4_K = selected_char_kind('ISO_10646')","tags":"","loc":"program/test_iso_10646_support.html"},{"title":"main – Fortran Program","text":"Uses json_module program~~main~~UsesGraph program~main main json_module json_module program~main->json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables json_data found n i z kijs kij id name Variables Type Attributes Name Initial type(json_file) :: json_data logical :: found integer :: n integer :: i real(kind=8), allocatable :: z (:) real(kind=8), allocatable :: kijs (:,:) real(kind=8), allocatable :: kij (:) character(len=50) :: id character(len=:), allocatable :: name","tags":"","loc":"program/main.html"}]}