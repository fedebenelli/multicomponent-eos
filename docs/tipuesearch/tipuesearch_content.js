var tipuesearch = {"pages":[{"title":" Multicomponent Equations of State ","text":"Multicomponent Equations of State Fortran program for the calculation of the residual Helmholtz Energy using the\nRKPR EoS (hence, PR and SRK are also included), for multicomponent mixtures. Developer Info Federico Benelli Doctoral student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"mixture – Multicomponent Equations of State ","text":"type, public :: mixture Inherits type~~mixture~~InheritsGraph type~mixture mixture type~pure_compound pure_compound type~mixture->type~pure_compound compounds type~quadratic quadratic type~mixture->type~quadratic mixing_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables compounds mixing_rule Source Code mixture Components Type Visibility Attributes Name Initial class( pure_compound ), public, allocatable :: compounds (:) class( quadratic ), public, allocatable :: mixing_rule Source Code type :: mixture class ( pure_compound ), allocatable :: compounds (:) class ( quadratic ), allocatable :: mixing_rule end type mixture","tags":"","loc":"type/mixture.html"},{"title":"kij_exp_t – Multicomponent Equations of State ","text":"type, public, extends( quadratic ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Inherits type~~kij_exp_t~~InheritsGraph type~kij_exp_t kij_exp_t type~quadratic quadratic type~kij_exp_t->type~quadratic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables T_star aij bij dkij2dt2 dkijdt kij kij_0 kij_inf lij Type-Bound Procedures get_kij mix Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: aij (:,:) matrix real(kind=wp), public, allocatable :: bij (:,:) matrix real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential term real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature real(kind=wp), public, allocatable :: lij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_tdep public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix procedure, public :: mix => quadratic_mix public subroutine quadratic_mix (self, T, compounds) Arguments Type Intent Optional Attributes Name class( quadratic ) :: self Mixing rule real(kind=wp), intent(in) :: T Temperature [K] class( pure_compound ), intent(in), allocatable :: compounds (:) Compounds to mix","tags":"","loc":"type/kij_exp_t.html"},{"title":"quadratic – Multicomponent Equations of State ","text":"type, public :: quadratic Basic Mixing rule with constant and Inherited by type~~quadratic~~InheritedByGraph type~quadratic quadratic type~mixture mixture type~mixture->type~quadratic mixing_rule type~kij_exp_t kij_exp_t type~kij_exp_t->type~quadratic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables aij bij kij lij Type-Bound Procedures mix Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) matrix real(kind=wp), public, allocatable :: bij (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: lij (:,:) matrix Type-Bound Procedures procedure, public :: mix => quadratic_mix public subroutine quadratic_mix (self, T, compounds) Arguments Type Intent Optional Attributes Name class( quadratic ) :: self Mixing rule real(kind=wp), intent(in) :: T Temperature [K] class( pure_compound ), intent(in), allocatable :: compounds (:) Compounds to mix","tags":"","loc":"type/quadratic.html"},{"title":"pr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Inherits type~~pr~~InheritsGraph type~pr pr type~pure_compound pure_compound type~pr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt del1 k name pc tc w Type-Bound Procedures a_t Source Code pr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 = 1 parameter. real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ) :: del1 = 1 !! \\delta_1 parameter. end type pr","tags":"","loc":"type/pr.html"},{"title":"pure_compound – Multicomponent Equations of State ","text":"type, public :: pure_compound Generic EoS Inherited by type~~pure_compound~~InheritedByGraph type~pure_compound pure_compound type~mixture mixture type~mixture->type~pure_compound compounds type~srk srk type~srk->type~pure_compound type~pr pr type~pr->type~pure_compound type~rkpr rkpr type~rkpr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k name pc tc w Type-Bound Procedures a_t Source Code pure_compound Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type :: pure_compound !! Generic EoS character ( len = 100 ) :: name !! Compound name real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound","tags":"","loc":"type/pure_compound.html"},{"title":"rkpr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: rkpr Inherits type~~rkpr~~InheritsGraph type~rkpr rkpr type~pure_compound pure_compound type~rkpr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt del1 k name pc tc w Type-Bound Procedures a_t Source Code rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr","tags":"","loc":"type/rkpr.html"},{"title":"srk – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Inherits type~~srk~~InheritsGraph type~srk srk type~pure_compound pure_compound type~srk->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt del1 k name pc tc w Type-Bound Procedures a_t Source Code srk Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 = 1+sqrt(2.d0) parameter. real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ) :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk","tags":"","loc":"type/srk.html"},{"title":"kij_tdep – Multicomponent Equations of State","text":"public subroutine kij_tdep(self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix Contents Variables T_star kij_0 kij_inf nc sp Source Code kij_tdep Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) real(kind=wp), public, allocatable :: kij_0 (:,:) real(kind=wp), public, allocatable :: kij_inf (:,:) integer, public :: nc integer, public :: sp (2) Source Code subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep","tags":"","loc":"proc/kij_tdep.html"},{"title":"quadratic_mix – Multicomponent Equations of State","text":"public subroutine quadratic_mix(self, T, compounds) Arguments Type Intent Optional Attributes Name class( quadratic ) :: self Mixing rule real(kind=wp), intent(in) :: T Temperature [K] class( pure_compound ), intent(in), allocatable :: compounds (:) Compounds to mix Contents Variables a aij b bij da2dt2 dadt daij2dt2 daijdt dkij2dt2 dkijdt i kij lij nc Source Code quadratic_mix Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: a (:) real(kind=wp), public, allocatable :: aij (:,:) real(kind=wp), public, allocatable :: b (:) real(kind=wp), public, allocatable :: bij (:,:) real(kind=wp), public, allocatable :: da2dt2 (:) real(kind=wp), public, allocatable :: dadt (:) real(kind=wp), public, allocatable :: daij2dt2 (:,:) real(kind=wp), public, allocatable :: daijdt (:,:) real(kind=wp), public, allocatable :: dkij2dt2 (:,:) real(kind=wp), public, allocatable :: dkijdt (:,:) integer, public :: i real(kind=wp), public, allocatable :: kij (:,:) real(kind=wp), public, allocatable :: lij (:,:) integer, public :: nc Source Code subroutine quadratic_mix ( self , T , compounds ) class ( quadratic ) :: self !! Mixing rule class ( pure_compound ), allocatable , intent ( in ) :: compounds (:) !! Compounds to mix real ( wp ), intent ( in ) :: T !! Temperature [K] real ( wp ), allocatable :: a (:), aij (:, :) real ( wp ), allocatable :: dadt (:), daijdt (:, :) real ( wp ), allocatable :: da2dt2 (:), daij2dt2 (:, :) real ( wp ), allocatable :: b (:), bij (:, :), lij (:, :) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , nc nc = size ( compounds ) ! ======================================================================= !   Calculate all the pure compounds atractive and repulsive !    parameters at T ! ----------------------------------------------------------------------- allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) do i = 1 , nc call compounds ( i )% a_t ( T ) a ( i ) = compounds ( i )% a dadt ( i ) = compounds ( i )% dadt da2dt2 ( i ) = compounds ( i )% da2dt2 b ( i ) = compounds ( i )% b end do ! ======================================================================= ! ======================================================================= !  Calculate the kij and lij matrices ! ----------------------------------------------------------------------- select type ( self ) class is ( quadratic ) kij = self % kij lij = self % lij dkijdt = 0 * kij dkij2dt2 = 0 * kij class is ( kij_exp_t ) call self % get_kij ( T , kij , dkijdt , dkij2dt2 ) lij = self % lij class default print * , \"Not implemented Kij rule\" end select self % kij = kij self % lij = lij ! ======================================================================= ! ======================================================================= ! Calculate each aij ! ----------------------------------------------------------------------- allocate ( aij ( nc , nc )) allocate ( bij ( nc , nc )) do i = 1 , nc aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) bij ( i , :) = ( 1 - lij ( i , :)) * ( b ( i ) + b (:)) / 2 end do self % aij = aij self % bij = bij ! ======================================================================= end subroutine quadratic_mix","tags":"","loc":"proc/quadratic_mix.html"},{"title":"a_parameter – Multicomponent Equations of State","text":"public subroutine a_parameter(self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Contents Variables Tc Tr ac k Source Code a_parameter Variables Type Visibility Attributes Name Initial real(kind=8), public :: Tc real(kind=8), public :: Tr real(kind=8), public :: ac real(kind=8), public :: k Source Code subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter","tags":"","loc":"proc/a_parameter.html"},{"title":"multicomponent_eos – Multicomponent Equations of State","text":"Uses mixing_rules constants cubic_eos module~~multicomponent_eos~~UsesGraph module~multicomponent_eos multicomponent_eos module~mixing_rules mixing_rules module~multicomponent_eos->module~mixing_rules module~cubic_eos cubic_eos module~multicomponent_eos->module~cubic_eos module~constants constants module~multicomponent_eos->module~constants module~mixing_rules->module~cubic_eos module~mixing_rules->module~constants module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types mixture Derived Types type, public :: mixture Components Type Visibility Attributes Name Initial class( pure_compound ), public, allocatable :: compounds (:) class( quadratic ), public, allocatable :: mixing_rule","tags":"","loc":"module/multicomponent_eos.html"},{"title":"mixing_rules – Multicomponent Equations of State","text":"Module that contains the available mixing rules to be used. Uses constants cubic_eos module~~mixing_rules~~UsesGraph module~mixing_rules mixing_rules module~constants constants module~mixing_rules->module~constants module~cubic_eos cubic_eos module~mixing_rules->module~cubic_eos module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mixing_rules~~UsedByGraph module~mixing_rules mixing_rules module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~mixing_rules Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types kij_exp_t quadratic Subroutines kij_tdep quadratic_mix Derived Types type, public, extends( quadratic ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: aij (:,:) matrix real(kind=wp), public, allocatable :: bij (:,:) matrix real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential term real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature real(kind=wp), public, allocatable :: lij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_tdep procedure, public :: mix => quadratic_mix type, public :: quadratic Basic Mixing rule with constant and Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) matrix real(kind=wp), public, allocatable :: bij (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: lij (:,:) matrix Type-Bound Procedures procedure, public :: mix => quadratic_mix Subroutines public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix public subroutine quadratic_mix (self, T, compounds) Arguments Type Intent Optional Attributes Name class( quadratic ) :: self Mixing rule real(kind=wp), intent(in) :: T Temperature [K] class( pure_compound ), intent(in), allocatable :: compounds (:) Compounds to mix","tags":"","loc":"module/mixing_rules.html"},{"title":"constants – Multicomponent Equations of State","text":"Used by module~~constants~~UsedByGraph module~constants constants module~mixing_rules mixing_rules module~mixing_rules->module~constants module~cubic_eos cubic_eos module~mixing_rules->module~cubic_eos module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~constants module~multicomponent_eos->module~mixing_rules module~multicomponent_eos->module~cubic_eos module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables A0 A1 B0 B1 C0 C1 Dfit ERRMAX RGAS wp Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: A0 = 0.0017 real(kind=wp), public, parameter :: A1 = -2.4407 real(kind=wp), public, parameter :: B0 = 1.9681 real(kind=wp), public, parameter :: B1 = 7.4513 real(kind=wp), public, parameter :: C0 = -2.7238 real(kind=wp), public, parameter :: C1 = 12.504 real(kind=wp), public, dimension(6) :: Dfit = [0.428363, 18.496215, 0.338426, 0.660, 789.723105, 2.512392] real(kind=wp), public, parameter :: ERRMAX = 1.D-8 real(kind=wp), public, parameter :: RGAS = 0.08314472d0 integer, public, parameter :: wp = 8","tags":"","loc":"module/constants.html"},{"title":"cubic_eos – Multicomponent Equations of State","text":"Module that encompass the calculations of the residual Helmholtz energy\nand related properties like fugacity coefficents. Uses constants module~~cubic_eos~~UsesGraph module~cubic_eos cubic_eos module~constants constants module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~cubic_eos~~UsedByGraph module~cubic_eos cubic_eos module~mixing_rules mixing_rules module~mixing_rules->module~cubic_eos module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~cubic_eos module~multicomponent_eos->module~mixing_rules Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types pr pure_compound rkpr srk Subroutines a_parameter Derived Types type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 = 1 parameter. real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public :: pure_compound Generic EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 = 1+sqrt(2.d0) parameter. real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter Subroutines public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate","tags":"","loc":"module/cubic_eos.html"},{"title":"main – Multicomponent Equations of State","text":"Uses json_module program~~main~~UsesGraph program~main main json_module json_module program~main->json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables found i id json_data kij kijs n name z Source Code main Variables Type Attributes Name Initial logical :: found integer :: i character(len=50) :: id type(json_file) :: json_data real(kind=8), allocatable :: kij (:) real(kind=8), allocatable :: kijs (:,:) integer :: n character(len=:), allocatable :: name real(kind=8), allocatable :: z (:) Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"program/main.html"},{"title":"mixture.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixture.f90~~EfferentGraph sourcefile~mixture.f90 mixture.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules multicomponent_eos Source Code mixture.f90 Source Code module multicomponent_eos use constants use mixing_rules use cubic_eos implicit none type :: mixture class ( pure_compound ), allocatable :: compounds (:) class ( quadratic ), allocatable :: mixing_rule end type mixture end module multicomponent_eos","tags":"","loc":"sourcefile/mixture.f90.html"},{"title":"mixing_rules.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixing_rules.f90->sourcefile~cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mixing_rules Source Code mixing_rules.f90 Source Code module mixing_rules !! Module that contains the available mixing rules to be used. use constants use cubic_eos implicit none type :: quadratic !! Basic Mixing rule with constant K_ij and l_ij real ( wp ), allocatable :: kij (:, :) !! K_ij matrix real ( wp ), allocatable :: lij (:, :) !! l_ij matrix real ( wp ), allocatable :: aij (:, :) !! a_ij matrix real ( wp ), allocatable :: bij (:, :) !! b_ij matrix contains procedure :: mix => quadratic_mix end type type , extends ( quadratic ) :: kij_exp_t !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{-T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module. real ( wp ), allocatable :: dkijdt (:, :) !! K_ij matrix real ( wp ), allocatable :: dkij2dt2 (:, :) !! K_ij matrix real ( wp ), allocatable :: kij_0 (:, :) !! Exponential term real ( wp ), allocatable :: kij_inf (:, :) !! K_ij at infinite Temperature real ( wp ), allocatable :: T_star (:, :) !! Reference temperature contains procedure :: get_kij => kij_tdep end type contains subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep subroutine quadratic_mix ( self , T , compounds ) class ( quadratic ) :: self !! Mixing rule class ( pure_compound ), allocatable , intent ( in ) :: compounds (:) !! Compounds to mix real ( wp ), intent ( in ) :: T !! Temperature [K] real ( wp ), allocatable :: a (:), aij (:, :) real ( wp ), allocatable :: dadt (:), daijdt (:, :) real ( wp ), allocatable :: da2dt2 (:), daij2dt2 (:, :) real ( wp ), allocatable :: b (:), bij (:, :), lij (:, :) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , nc nc = size ( compounds ) ! ======================================================================= !   Calculate all the pure compounds atractive and repulsive !    parameters at T ! ----------------------------------------------------------------------- allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) do i = 1 , nc call compounds ( i )% a_t ( T ) a ( i ) = compounds ( i )% a dadt ( i ) = compounds ( i )% dadt da2dt2 ( i ) = compounds ( i )% da2dt2 b ( i ) = compounds ( i )% b end do ! ======================================================================= ! ======================================================================= !  Calculate the kij and lij matrices ! ----------------------------------------------------------------------- select type ( self ) class is ( quadratic ) kij = self % kij lij = self % lij dkijdt = 0 * kij dkij2dt2 = 0 * kij class is ( kij_exp_t ) call self % get_kij ( T , kij , dkijdt , dkij2dt2 ) lij = self % lij class default print * , \"Not implemented Kij rule\" end select self % kij = kij self % lij = lij ! ======================================================================= ! ======================================================================= ! Calculate each aij ! ----------------------------------------------------------------------- allocate ( aij ( nc , nc )) allocate ( bij ( nc , nc )) do i = 1 , nc aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) bij ( i , :) = ( 1 - lij ( i , :)) * ( b ( i ) + b (:)) / 2 end do self % aij = aij self % bij = bij ! ======================================================================= end subroutine quadratic_mix end module mixing_rules","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"constants.f90 – Multicomponent Equations of State","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants implicit none integer , parameter :: wp = 8 real ( wp ), parameter :: RGAS = 0.08314472d0 real ( wp ), parameter :: A0 = 0.0017 , B0 = 1.9681 , C0 = - 2.7238 real ( wp ), parameter :: A1 = - 2.4407 , B1 = 7.4513 , C1 = 1 2.504 real ( wp ), dimension ( 6 ) :: Dfit = [ 0.428363 , 1 8.496215 , 0.338426 , & 0.660 , 78 9.723105 , 2.512392 ] real ( wp ), parameter :: ERRMAX = 1.D-8 end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"cubic_eos.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~cubic_eos.f90~~EfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~cubic_eos.f90~~AfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~cubic_eos.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cubic_eos Source Code cubic_eos.f90 Source Code module cubic_eos !! Module that encompass the calculations of the residual Helmholtz energy !! and related properties like fugacity coefficents. use constants implicit none type :: pure_compound !! Generic EoS character ( len = 100 ) :: name !! Compound name real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ) :: del1 = 1 !! \\delta_1 parameter. end type pr type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ) :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr contains subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter !subroutine aijTder(nc, ac, tc, k, T, kij_calc, aij, daijdT, daij2dT2) !   !! Calculate the binary atractive term matrix !   implicit none !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   class(*) :: kij_calc !! Kij calculator object !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(out) :: aij(nc, nc) !! Atractive binary terms matrix !   real(wp), intent(out) :: daijdT(nc, nc) !! Atractive binary terms matrix first derivative with temperature !   real(wp), intent(out) :: daij2dT2(nc, nc) !! Atractive binary terms matrix second derivative with temperature !   real(wp), allocatable :: kij(:, :), dkijdt(:, :), dkij2dt2(:, :) ! kij and T derivatives !   real(wp) :: a(nc), dadT(nc), da2dT2(nc) ! Atractive parameter and T derivatives !   real(wp) :: b(nc), bij(nc, nc) ! Repulsive parameter (just to use as input in subroutine) !   b = 0  ! Here only the aij for the mixture, so there is no need to use the real b !   ! Calculate pure compounds atractive parameters at T !   call aTder(nc, ac, k, tc, T, a, dadT, da2dT2) !   select type (kij_calc) !   type is (kij_constant) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   type is (kij_exp_t) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   end select !end subroutine aijTder !subroutine DmixTnder(& !        nc, ac, tc, k, & !        T, n, & !        D, dDdni, dD2dniT2, dD2dnij2, dDdT, dD2dT2) !   !! Atractive parameter of a mixture and it's derivatives !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(in) :: n(nc) !! Matrix with number of moles !   real(wp), intent(out) :: D !! Mixture atractive parameter (times moles&#94;2) !   real(wp), intent(out) :: dDdni(nc) !! Atractive parameter first derivative with number of moles !   real(wp), intent(out) :: dD2dniT2(nc) !! Atractive parameter second derivative with moles and Tempeature !   real(wp), intent(out) :: dD2dnij2(nc, nc) !! Atractive parameter second derivative with number of moles !   real(wp), intent(out) :: dDdT(nc) !! Atractive parameter first derivative with Tempeature !   real(wp), intent(out) :: dD2dT2(nc) !! Atractive parameter first derivative with Tempeature !   real(wp) :: aij(nc, nc), daijdT(nc, nc), daij2dT2(nc, nc) !   real(wp) :: aux, aux2 !   integer :: i, j !   ! TODO: An already calculated aij matrix could be the input !   call aijTder(nc, ac, tc, k, T, aij, daijdT, daij2dT2) !   D = 0.0_wp !   dDdT = 0.0_wp !   dD2dT2 = 0.0_wp !   do i = 1, nc !      aux = 0.0_wp !      aux2 = 0.0_wp !      dDdni(i) = 0.0_wp !      dD2dniT2(i) = 0.0_wp !      do j = 1, nc !         dDdni(i) = dDdni(i) + 2*n(j)*aij(i, j) !         dD2dniT2(i) = dD2dniT2(i) + 2*n(j)*daijdT(i, j) !         dD2dnij2(i, j) = 2*aij(i, j) !         aux = aux + n(j)*aij(i, j) !         aux2 = aux2 + n(j)*daij2dT2(i, j) !      end do !      D = D + n(i)*aux !      dDdT = dDdT + n(i)*dD2dniT2(i)/2 !      dD2dT2 = dD2dT2 + n(i)*aux2 !   end do !end subroutine DmixTnder !subroutine d1nder(nc, n, d1, d1_mix, dD1dni, dD12dnij2) !   !! delta_1 of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components. !   real(wp), intent(in) :: n(nc) !! Array of mole numbers for each component. !   real(wp), intent(in) :: d1(nc) !! Array of delta 1 parameters for each component. !   real(wp), intent(out) :: d1_mix !! Mixture's delta 1 !   real(wp), intent(out) :: dD1dni(nc) !! delta1 parameter first derivative with composition. !   real(wp), intent(out) :: dD12dnij2(nc, nc) !! delta1 parameter second derivative with composition. !   integer :: i, j !   real(wp) :: totn ! Total number of moles !   d1_mix = 0.0_wp !   d1_mix = sum(n*d1) !   totn = sum(n) !   D1_mix = D1_mix/totn !   dD1dni = (d1 - d1_mix)/totn !   do i = 1, nc !      do j = 1, nc !         dD12dnij2(i, j) = (2.0_wp*d1_mix - d1(i) - d1(j))/totn**2 !      end do !   end do !end subroutine d1nder !subroutine Bmixnder(nc, n, bij, B_mix, dBdni, dB2dnij2) !   !! Repulsive parameter of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: n(nc) !! Number of moles of each component !   real(wp), intent(in) :: bij(nc, nc) !! Repulsive parameter matrix !   real(wp), intent(out) :: B_mix !! Mixture repulsive parameter !   real(wp), intent(out) :: dBdni(nc) !! Repulsive parameter derivatives wrt number of moles !   real(wp), intent(out) :: dB2dnij2(nc, nc) !! Repulsive parameter second derivatives wrt number of moles !   real(wp) :: totn, aux(nc) !   integer :: i, j !   totn = sum(n) !   B_mix = 0.0_wp !   aux = 0.0_wp !   do i = 1, nc !      do j = 1, nc !         aux(i) = aux(i) + n(j)*bij(i, j) !      end do !      B_mix = B_mix + n(i)*aux(i) !   end do !   B_mix = B_mix/totn !   do i = 1, nc !      dBdni(i) = (2*aux(i) - B_mix)/totn !      do j = 1, i !         dB2dnij2(i, j) = (2*bij(i, j) - dBdni(i) - dBdni(j))/totn !         dB2dnij2(j, i) = dB2dnij2(i, j) !      end do !   end do !end subroutine Bmixnder end module cubic_eos","tags":"","loc":"sourcefile/cubic_eos.f90.html"},{"title":"main.f90 – Multicomponent Equations of State","text":"Contents Programs main Source Code main.f90 Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"sourcefile/main.f90.html"}]}