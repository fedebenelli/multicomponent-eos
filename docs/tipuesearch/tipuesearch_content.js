var tipuesearch = {"pages":[{"title":" Multicomponent Equations of State ","text":"Multicomponent Equations of State Developer Info Federico Benelli Doctoral student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"constants.f90 – Multicomponent Equations of State","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~cubic_parameter.f90 cubic_parameter.f90 sourcefile~cubic_parameter.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~rkpr.f90 rkpr.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants implicit none integer , parameter :: wp = 8 real ( wp ), parameter :: RGAS = 0.08314472d0 real ( wp ), parameter :: A0 = 0.0017 , B0 = 1.9681 , C0 = - 2.7238 real ( wp ), parameter :: A1 = - 2.4407 , B1 = 7.4513 , C1 = 1 2.504 real ( wp ), dimension ( 6 ) :: Dfit = [ 0.428363 , 1 8.496215 , 0.338426 , & 0.660 , 78 9.723105 , 2.512392 ] real ( wp ), parameter :: ERRMAX = 1.D-8 end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"cubic_eos.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~cubic_eos.f90~~EfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~cubic_eos.f90~~AfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cubic_eos Source Code cubic_eos.f90 Source Code module cubic_eos !! Module that encompass the calculations of the residual Helmholtz energy !! and related properties like fugacity coefficents. use constants use mixing_rules implicit none type :: pure_compound !! Generic EoS real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ), private :: del1 = 1 !! \\delta_1 parameter. end type pr type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ), private :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr contains subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter !subroutine aijTder(nc, ac, tc, k, T, kij_calc, aij, daijdT, daij2dT2) !   !! Calculate the binary atractive term matrix !   implicit none !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   class(*) :: kij_calc !! Kij calculator object !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(out) :: aij(nc, nc) !! Atractive binary terms matrix !   real(wp), intent(out) :: daijdT(nc, nc) !! Atractive binary terms matrix first derivative with temperature !   real(wp), intent(out) :: daij2dT2(nc, nc) !! Atractive binary terms matrix second derivative with temperature !   real(wp), allocatable :: kij(:, :), dkijdt(:, :), dkij2dt2(:, :) ! kij and T derivatives !   real(wp) :: a(nc), dadT(nc), da2dT2(nc) ! Atractive parameter and T derivatives !   real(wp) :: b(nc), bij(nc, nc) ! Repulsive parameter (just to use as input in subroutine) !   b = 0  ! Here only the aij for the mixture, so there is no need to use the real b !   ! Calculate pure compounds atractive parameters at T !   call aTder(nc, ac, k, tc, T, a, dadT, da2dT2) !   select type (kij_calc) !   type is (kij_constant) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   type is (kij_exp_t) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   end select !end subroutine aijTder !subroutine DmixTnder(& !        nc, ac, tc, k, & !        T, n, & !        D, dDdni, dD2dniT2, dD2dnij2, dDdT, dD2dT2) !   !! Atractive parameter of a mixture and it's derivatives !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(in) :: n(nc) !! Matrix with number of moles !   real(wp), intent(out) :: D !! Mixture atractive parameter (times moles&#94;2) !   real(wp), intent(out) :: dDdni(nc) !! Atractive parameter first derivative with number of moles !   real(wp), intent(out) :: dD2dniT2(nc) !! Atractive parameter second derivative with moles and Tempeature !   real(wp), intent(out) :: dD2dnij2(nc, nc) !! Atractive parameter second derivative with number of moles !   real(wp), intent(out) :: dDdT(nc) !! Atractive parameter first derivative with Tempeature !   real(wp), intent(out) :: dD2dT2(nc) !! Atractive parameter first derivative with Tempeature !   real(wp) :: aij(nc, nc), daijdT(nc, nc), daij2dT2(nc, nc) !   real(wp) :: aux, aux2 !   integer :: i, j !   ! TODO: An already calculated aij matrix could be the input !   call aijTder(nc, ac, tc, k, T, aij, daijdT, daij2dT2) !   D = 0.0_wp !   dDdT = 0.0_wp !   dD2dT2 = 0.0_wp !   do i = 1, nc !      aux = 0.0_wp !      aux2 = 0.0_wp !      dDdni(i) = 0.0_wp !      dD2dniT2(i) = 0.0_wp !      do j = 1, nc !         dDdni(i) = dDdni(i) + 2*n(j)*aij(i, j) !         dD2dniT2(i) = dD2dniT2(i) + 2*n(j)*daijdT(i, j) !         dD2dnij2(i, j) = 2*aij(i, j) !         aux = aux + n(j)*aij(i, j) !         aux2 = aux2 + n(j)*daij2dT2(i, j) !      end do !      D = D + n(i)*aux !      dDdT = dDdT + n(i)*dD2dniT2(i)/2 !      dD2dT2 = dD2dT2 + n(i)*aux2 !   end do !end subroutine DmixTnder !subroutine d1nder(nc, n, d1, d1_mix, dD1dni, dD12dnij2) !   !! delta_1 of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components. !   real(wp), intent(in) :: n(nc) !! Array of mole numbers for each component. !   real(wp), intent(in) :: d1(nc) !! Array of delta 1 parameters for each component. !   real(wp), intent(out) :: d1_mix !! Mixture's delta 1 !   real(wp), intent(out) :: dD1dni(nc) !! delta1 parameter first derivative with composition. !   real(wp), intent(out) :: dD12dnij2(nc, nc) !! delta1 parameter second derivative with composition. !   integer :: i, j !   real(wp) :: totn ! Total number of moles !   d1_mix = 0.0_wp !   d1_mix = sum(n*d1) !   totn = sum(n) !   D1_mix = D1_mix/totn !   dD1dni = (d1 - d1_mix)/totn !   do i = 1, nc !      do j = 1, nc !         dD12dnij2(i, j) = (2.0_wp*d1_mix - d1(i) - d1(j))/totn**2 !      end do !   end do !end subroutine d1nder !subroutine Bmixnder(nc, n, bij, B_mix, dBdni, dB2dnij2) !   !! Repulsive parameter of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: n(nc) !! Number of moles of each component !   real(wp), intent(in) :: bij(nc, nc) !! Repulsive parameter matrix !   real(wp), intent(out) :: B_mix !! Mixture repulsive parameter !   real(wp), intent(out) :: dBdni(nc) !! Repulsive parameter derivatives wrt number of moles !   real(wp), intent(out) :: dB2dnij2(nc, nc) !! Repulsive parameter second derivatives wrt number of moles !   real(wp) :: totn, aux(nc) !   integer :: i, j !   totn = sum(n) !   B_mix = 0.0_wp !   aux = 0.0_wp !   do i = 1, nc !      do j = 1, nc !         aux(i) = aux(i) + n(j)*bij(i, j) !      end do !      B_mix = B_mix + n(i)*aux(i) !   end do !   B_mix = B_mix/totn !   do i = 1, nc !      dBdni(i) = (2*aux(i) - B_mix)/totn !      do j = 1, i !         dB2dnij2(i, j) = (2*bij(i, j) - dBdni(i) - dBdni(j))/totn !         dB2dnij2(j, i) = dB2dnij2(i, j) !      end do !   end do !end subroutine Bmixnder end module cubic_eos","tags":"","loc":"sourcefile/cubic_eos.f90.html"},{"title":"mixture.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixture.f90~~EfferentGraph sourcefile~mixture.f90 mixture.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mixture Source Code mixture.f90 Source Code module mixture use constants use mixing_rules use cubic_eos implicit none type :: mix class ( pure_compound ), allocatable :: compounds (:) class ( kij_constant ), allocatable :: kij_calculator class ( lij_constant ), allocatable :: lij_calculator real ( wp ), allocatable :: kij_matrix (:, :) real ( wp ), allocatable :: aij (:, :) real ( wp ), allocatable :: bij (:, :) contains procedure :: get_aij => aij !procedure :: get_kij => kij end type mix contains subroutine aij ( self , T ) class ( mix ) :: self !! Mixture object real ( wp ), intent ( in ) :: T !! Temperature [K] class ( kij_constant ), pointer :: kij_rule real ( wp ), allocatable :: a (:) real ( wp ), allocatable :: dadt (:) real ( wp ), allocatable :: da2dt2 (:) real ( wp ), allocatable :: b (:) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , j , nc nc = size ( self % compounds ) allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) ! Calculate all the pure compounds atractive parameters at T do i = 1 , nc call self % compounds ( i )% a_t ( T ) a ( i ) = self % compounds ( i )% a dadt ( i ) = self % compounds ( i )% dadt da2dt2 ( i ) = self % compounds ( i )% da2dt2 b ( i ) = self % compounds ( i )% b end do ! Calculate the kij matrix associate ( kij_rule => self % kij_calculator ) select type ( kij_rule ) type is ( kij_constant ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) type is ( kij_exp_t ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) class default print * , \"Error\" end select self % kij_matrix = kij end associate allocate ( self % aij ( nc , nc )) do i = 1 , nc self % aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) end do end subroutine aij end module mixture","tags":"","loc":"sourcefile/mixture.f90.html"},{"title":"rkpr.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~rkpr.f90~~EfferentGraph sourcefile~rkpr.f90 rkpr.f90 sourcefile~constants.f90 constants.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rkpr Source Code rkpr.f90 Source Code module rkpr use constants implicit none contains end module rkpr","tags":"","loc":"sourcefile/rkpr.f90.html"},{"title":"tmp.f90 – Multicomponent Equations of State","text":"Contents Programs geometry Modules g Source Code tmp.f90 Source Code module g ! define the first object class real :: pi = 3.1415926535897931 type :: Rectangle real :: base , height contains procedure :: get_area => rectangle_area end type Rectangle contains !  Computation of area for rectangles. subroutine rectangle_area ( this , area ) class ( Rectangle ), intent ( in ) :: this real :: area area = this % base * this % height end subroutine rectangle_area subroutine select_figure ( this , obj ) class ( * ), allocatable , intent ( in out ) :: this integer , intent ( in ) :: obj select case ( obj ) case ( 1 ) allocate ( Rectangle :: this ) end select end subroutine select_figure end module g program geometry ! for both types in a single function use g class ( * ), allocatable :: figure real :: area call select_figure ( figure , 1 ) select type ( figure ) type is ( Rectangle ) figure % base = 2 figure % height = 3 call figure % get_area ( area ) end select print * , '' end program geometry","tags":"","loc":"sourcefile/tmp.f90.html"},{"title":"mixing_rules.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mixing_rules Source Code mixing_rules.f90 Source Code module mixing_rules !! Module that contains the available mixing rules to be used. use constants implicit none type :: kij_constant !! K_ij constant type real ( wp ), allocatable :: kij (:, :) !! K_ij matrix contains procedure :: get_kij => kij_const end type type , extends ( kij_constant ) :: kij_exp_t !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{-T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module. real ( wp ), allocatable :: dkijdt (:, :) !! K_ij matrix real ( wp ), allocatable :: dkij2dt2 (:, :) !! K_ij matrix real ( wp ), allocatable :: kij_0 (:, :) !! Exponential real ( wp ), allocatable :: kij_inf (:, :) !! K_ij at infinite Temperature real ( wp ), allocatable :: T_star (:, :) !! Reference temperature contains procedure :: get_kij => kij_tdep end type type :: lij_constant real ( wp ), allocatable :: lij (:, :) end type lij_constant contains subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep subroutine kij_const ( self , T , kij , dkijdt , dkij2dt2 ) class ( kij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix kij = self % kij dkijdt = 0 * kij dkij2dt2 = 0 * kij end subroutine kij_const subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic end module mixing_rules","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"cubic_parameter.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~cubic_parameter.f90~~EfferentGraph sourcefile~cubic_parameter.f90 cubic_parameter.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_parameter.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parameters converter Source Code cubic_parameter.f90 Source Code module parameters use iso_fortran_env implicit none real ( 8 ), save :: Tc , dc real ( 8 ), save :: a , b , del1 end module parameters module converter use iso_fortran_env use constants implicit none contains ! ============================================================================= !  Subroutines to obtain EOS parameters from critical constants ! ----------------------------------------------------------------------------- subroutine pr_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc ! Critical temperature real ( 8 ), intent ( in ) :: Pc ! Critical pressure real ( 8 ), intent ( in ) :: w ! Accentric factor real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: ac ! ac parameter real ( 8 ), intent ( out ) :: b ! Covolume real ( 8 ), intent ( out ) :: m ! Constant to calculate a(T) ! Internal varibles real ( 8 ) :: del1 = 1.0d0 + sqrt ( 2.d0 ) ! delta_1 for PR since the parameters are calculated based on the RKPR method real ( 8 ) :: OMa , OMb , Zc , Vceos ! real ( 8 ) :: RT ! R*T product RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc ! m constant to calculate a depending on temperature if ( w <= 0.491 ) then ! m from PR m = 0.37464 + 1.54226 * w - 0.26992 * w ** 2 end if if ( w > 0.491 ) then ! PR78 m = 0.379642 + 1.48503 * w - 0.164423 * w ** 2 + 0.016666 * w ** 3 end if end subroutine pr_params_from_crit subroutine srk_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: Pc real ( 8 ), intent ( out ) :: w real ( 8 ), intent ( in ) :: R real ( 8 ), intent ( out ) :: ac real ( 8 ), intent ( out ) :: b real ( 8 ), intent ( out ) :: m real ( 8 ) :: del1 = 1.0D0 real ( 8 ) :: OMa , OMb , Zc , Vceos real ( 8 ) :: RT RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc m = 0.48 + 1.574 * w - 0.175 * w ** 2 end subroutine srk_params_from_crit subroutine rkpr_params_from_crit ( & Tc , Pc , w , R , ac , b , k , del1 , Vceos , T , Pvdat , RhoLsat & ) !! Get the RKPR EOS parameters from the substance critical properties. ! Input real ( 8 ), intent ( in ) :: Tc !! Critical temperature real ( 8 ), intent ( in ) :: Pc !! Critical pressure real ( 8 ), intent ( in ) :: w !! accentric factor real ( 8 ), intent ( in ) :: R !! Gas constant ! Optional cases where extra specifications are made real ( 8 ), intent ( inout ), optional :: del1 !! delta_1 real ( 8 ), intent ( inout ), optional :: Vceos !! Critical volume at specification real ( 8 ), intent ( in ), optional :: T !! Temperature used to either estimate k or del1 real ( 8 ), intent ( inout ), optional :: Pvdat !! Vapor pressure used to estimate k real ( 8 ), intent ( in ), optional :: RhoLsat !! Saturation density used to estimate del1 !------------------------------------------------------------------------ real ( 8 ), intent ( out ) :: ac !! ac parameter real ( 8 ), intent ( out ) :: b !! covolume real ( 8 ), intent ( out ) :: k !! k to calculate \"a\" with ac and T real ( 8 ) :: OMa , OMb , Zc , RT , del1ini , dc , Tr , & a , Pv , RHOL , RHOV , phiL , delta_k , Pold , oldk , & Trho , RHOld , del1_old , delta_del1 logical :: del1_spec , Pv_spec , rhoL_spec del1_spec = . false . Pv_spec = . false . rhoL_spec = . false . if ( present ( del1 )) then del1_spec = . true . !print *, \"Specified del1\" end if if ( present ( T )) then if ( present ( Pvdat )) then Pv_spec = . true . !print *, \"Specified Pv\" end if end if if ( present ( T )) then if ( present ( RhoLsat )) then rhoL_spec = . true . !print *, \"Specified RhoLsat\" end if end if ! Initialize delta_1 and get the value that statisfies the Zc ! condition ! ----------------------------------------------------------------------- RT = R * Tc if ( present ( Vceos )) then ! Usual specification with Vceos Zc = Pc * Vceos / RT del1ini = D ( 1 ) + D ( 2 ) * ( D ( 3 ) - Zc ) ** D ( 4 ) + D ( 5 ) * ( D ( 3 ) - Zc ) ** D ( 6 ) call getdel1 ( Zc , del1ini , del1 ) end if if ( rhoL_spec ) then Trho = T / Tc del1 = 2.0 ! initial value RHOld = 0.d0 end if ! Calculate the inbetween parameters and finally get ac and b ! ----------------------------------------------------------------------- 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc ! Obtain the k parameter ! ----------------------------------------------------------------------- dc = Pc / Zc / RT Vceos = 1.0d0 / dc ! initial guess for k parameter k = ( A1 * Zc + A0 ) * w ** 2 + ( B1 * Zc + B0 ) * w + ( C1 * Zc + C0 ) a = ac * ( 3 / ( 2 + Tr )) ** k if ( del1_spec ) then Vceos = Zc * RT / Pc end if if ( Pv_spec ) then ! added 29/06/2013 in order to allow for better reproductions of Pv curves Tr = T / Tc else Tr = 0.7d0 Pvdat = Pc * 10 **- ( 1.0d0 + w ) end if ! Find the value of k that fits with the expected Pv call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) if ( Pv > Pvdat ) then delta_k = 0.1 else delta_k = - 0.1 end if do while ( abs ( Pv - Pvdat ) / Pvdat > 0.005 ) Pold = Pv oldk = k k = k + delta_k a = ac * ( 3 / ( 2 + Tr )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) delta_k = - ( Pv - Pvdat ) * ( k - oldk ) / ( Pv - Pold ) end do if ( rhoL_spec ) then ! November 2011 for RKPR specifying T, RHOLsat if ( abs ( Trho - 0.70 ) > 1.d-2 ) then ! get calculated RHOL when Trho is no 0.70 Pvdat = Pc * 10 **- (( 1. / Trho - 1 d0 ) * 7 * ( 1.0D0 + w ) / 3 ) a = ac * ( 3 / ( 2 + Trho )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Trho , Pvdat , Pv , RHOL , RHOV , phiL ) end if if ( RHOld == 0.d0 ) then del1_old = del1 ! condition for the strange case that del1=2 is solution if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) del1 = 2.1 else delta_del1 = - ( RHOL - RhoLsat ) * ( del1 - del1_old ) / ( RHOL - RHOld ) del1_old = del1 del1 = del1 + delta_del1 end if RHOld = RHOL if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) go to 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc end if end subroutine rkpr_params_from_crit ! ============================================================================= ! ========================================================================== !  Subroutines to obtain critical constants from EOS parameters ! -------------------------------------------------------------------------- subroutine pr_critical_from_params ( ac , b , m , R , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0D0 + sqrt ( 2.0 ) real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * R * b ) Pc = OMb * R * Tc / b Vceos = Zc * R * Tc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine pr_critical_from_params subroutine srk_critical_from_params ( ac , b , m , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0d0 real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = - 0.175 be = 1.574 ga = 0.48 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine srk_critical_from_params subroutine rkpr_critical_from_params ( ac , b , del1 , k , Tc , Pc , w , Vceos ) use constants real ( 8 ), intent ( in ) :: ac ! ac parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: del1 ! delta_1 parameter real ( 8 ), intent ( in ) :: k ! k parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! Accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume real ( 8 ) :: Zc , OMa , OMb , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = A1 * Zc + A0 be = B1 * Zc + B0 ga = C1 * Zc + C0 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine rkpr_critical_from_params ! ========================================================================== ! ========================================================================== !  Extra subroutines ! -------------------------------------------------------------------------- subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) real ( 8 ), intent ( in ) :: del1 ! RKPR delta_1 parameter real ( 8 ), intent ( out ) :: Zc ! Critical compressibility factor real ( 8 ), intent ( out ) :: OMa ! real ( 8 ), intent ( out ) :: OMb ! real ( 8 ) :: d1 , y d1 = ( 1.d0 + del1 ** 2.d0 ) / ( 1.d0 + del1 ) y = 1.d0 + ( 2.d0 * ( 1.d0 + del1 )) ** ( 1.0d0 / 3.d0 ) + ( 4.d0 / ( 1.d0 + del1 )) ** ( 1.0d0 / 3 ) OMa = ( 3.d0 * y * y + 3.d0 * y * d1 + d1 ** 2.d0 + d1 - 1.0d0 ) / ( 3.d0 * y + d1 - 1.0d0 ) ** 2.d0 OMb = 1.d0 / ( 3.d0 * y + d1 - 1.0d0 ) Zc = y / ( 3.d0 * y + d1 - 1.0d0 ) end subroutine get_Zc_OMa_OMb subroutine getdel1 ( Zc_in , del1_ini , del1 ) real ( 8 ), intent ( in ) :: Zc_in real ( 8 ), intent ( in ) :: del1_ini real ( 8 ), intent ( out ) :: del1 real ( 8 ) :: d1 , y , del1_old , Zc , Z_old , aux , error = 1.d0 del1 = del1_ini d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Zc = y / ( 3 * y + d1 - 1.0d0 ) del1_old = del1 if ( Zc . gt . Zc_in ) then del1 = 1.01 * del1 else del1 = 0.99 * del1 end if do while ( error >= 1.0d-6 ) d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Z_old = Zc Zc = y / ( 3 * y + d1 - 1.0d0 ) aux = del1 del1 = del1 - ( Zc - Zc_in ) * ( del1 - del1_old ) / ( Zc - Z_old ) del1_old = aux error = abs ( Zc - Zc_in ) end do end subroutine getdel1 recursive subroutine VaporPressure ( & a , b , del1 , Tc , dc , Tr , PVini , Pv , RHOL , RHOV , phiL & ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: dc real ( 8 ), intent ( in ) :: Tr real ( 8 ), intent ( in ) :: PVini real ( 8 ), intent ( out ) :: Pv real ( 8 ), intent ( out ) :: RHOL real ( 8 ), intent ( out ) :: RHOV real ( 8 ), intent ( out ) :: phiL real ( 8 ) :: dphi = 0.d0 , P , T , V , phi , phiV , dphiold , Pold , Plast P = PVini T = Tr * Tc do while ( RHOL < 0.9 * dc . or . RHOV > dc ) if ( RHOL < 0.9 * dc ) then P = 1.01 * P else if ( RHOV > dc ) then P = 0.99 * P end if call VCALC ( 1 , a , b , del1 , T , P , V ) RHOL = 1 / V call VCALC ( - 1 , a , b , del1 , T , P , V ) ! SOLVE for vapor density RHOV = 1 / V end do call FUG_CALC ( a , b , del1 , T , P , 1 / RHOL , phi ) phiL = phi call FUG_CALC ( a , b , del1 , T , P , V , phi ) phiV = phi dphiold = dphi dphi = phiV - phiL ! ASK: Is this really a recursion? Plast = P if ( ABS ( dphi ) . gt . ERRMAX ) then Pold = Plast Plast = P if ( dphiold == 0.0D0 . or . Tr . gt . 0.975 ) then P = P * ( phiL / phiV ) else P = Plast - dphi * ( Plast - Pold ) / ( dphi - dphiold ) end if call VaporPressure ( a , b , del1 , Tc , dc , Tr , P , Pv , RHOL , RHOV , phiL ) end if PV = P return end recursive subroutine VCALC ( ITYP , a , b , del1 , T , P , V ) ! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use constants , only : RGAS integer , intent ( in ) :: ITYP ! Type of root desired 1 for liquid -1 for vapor real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( out ) :: V ! Internal variables integer :: ITER logical :: FIRST_RUN real ( 8 ) :: ZETMIN , ZETMAX , ZETA , F , F_V , F_2V , F_N , & PCALC , del , AT , DER , VVAP , AVAP FIRST_RUN = . TRUE . ITER = 0 ZETMIN = 0.D0 ZETMAX = . 99 D0 if ( ITYP . GT . 0 ) then ! Liquid estimate ZETA = . 5 D0 else ! Ideal gas estimate ZETA = MIN (. 5 D0 , b * P / ( RGAS * T )) end if del = 1.d0 do while ( abs ( del ) > 1 d - 10 ) V = b / ZETA ITER = ITER + 1 CALL vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) PCALC = RGAS * T * ( 1 / V - F_V ) if ( PCALC . GT . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = F - LOG ( V ) + V * P / ( T * RGAS ) DER = RGAS * T * ( F_2V + 1.d0 ) / b DEL = - ( PCALC - P ) / DER ZETA = ZETA + MAX ( MIN ( DEL , 0.1d0 ), - 0.1d0 ) if ( ZETA . GT . ZETMAX . OR . ZETA . LT . ZETMIN ) then ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end if end do if ( ITYP == 0 ) then VVAP = V AVAP = AT ! Calculate Liquid volume and It's energy call VCALC ( 1 , a , b , del1 , T , P , V ) call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) AT = F - LOG ( V ) + V * P / ( T * RGAS ) if ( AT . GT . AVAP ) V = VVAP end if end subroutine VCALC subroutine vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) ! CALCULATES THE CONTRIBUTION TO THE RESIDUAL, REDUCED HELMHOLZ ENERGY (F) ! AND ITS FIRST AND SECOND DERIVATIVE WRT V use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T ! Temperature [K] real ( 8 ), intent ( in ) :: V ! Volume: [mL/mol] or [mL] for checking n-derivatives real ( 8 ), intent ( out ) :: F ! A&#94;RES/RT CONTRIBUTION (DIMENSIONLESS) or (MOLES) real ( 8 ), intent ( out ) :: F_V ! 1ST V-DERIVATIVE OF F real ( 8 ), intent ( out ) :: F_2V ! 1ST V-DERIVATIVE OF F_V  (*V**2) real ( 8 ), intent ( out ) :: F_N ! 1ST N-DERIVATIVE OF F real ( 8 ) :: C , aRT , ETA , SUMC , SUMD , REP , ATT , ATTV , REPV , REP2V , ATT2V C = ( 1 - del1 ) / ( 1 + del1 ) aRT = a / ( RGAS * T ) ETA = 0.25 * b / V SUMC = c * b + V SUMD = del1 * b + V REP = - log ( 1 - 4 * ETA ) ATT = aRT * LOG ( SUMD / SUMC ) / ( b * ( C - del1 )) ATTV = aRT / SUMC / SUMD REPV = 1 / ( 1 - 4 * ETA ) - 1 REP2V = 1 / ( 1 - 4 * ETA ) ** 2 - 1 ATT2V = aRT * V ** 2 * ( 1 / SUMD ** 2 - 1 / SUMC ** 2 ) / ( b * ( C - del1 )) F = REP + ATT F_V = ( - REPV / V + ATTV ) F_2V = REP2V - ATT2V F_N = REP + ATT - V * F_V end subroutine FUG_CALC ( a , b , del1 , T , P , V , phi ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( in ) :: V real ( 8 ), intent ( out ) :: phi real ( 8 ) :: RT , Z , F , F_V , F_2V , F_N RT = RGAS * T Z = P * V / RT call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) phi = exp ( F_N ) / Z end ! ========================================================================== end module converter","tags":"","loc":"sourcefile/cubic_parameter.f90.html"},{"title":"main.f90 – Multicomponent Equations of State","text":"Contents Programs main Source Code main.f90 Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"pr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Inherits type~~pr~~InheritsGraph type~pr pr type~pure_compound pure_compound type~pr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k pc tc w Type-Bound Procedures a_t Source Code pr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ), private :: del1 = 1 !! \\delta_1 parameter. end type pr","tags":"","loc":"type/pr.html"},{"title":"pure_compound – Multicomponent Equations of State ","text":"type, public :: pure_compound Generic EoS Inherited by type~~pure_compound~~InheritedByGraph type~pure_compound pure_compound type~pr pr type~pr->type~pure_compound type~rkpr rkpr type~rkpr->type~pure_compound type~srk srk type~srk->type~pure_compound type~mix mix type~mix->type~pure_compound compounds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k pc tc w Type-Bound Procedures a_t Source Code pure_compound Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type :: pure_compound !! Generic EoS real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound","tags":"","loc":"type/pure_compound.html"},{"title":"rkpr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: rkpr Inherits type~~rkpr~~InheritsGraph type~rkpr rkpr type~pure_compound pure_compound type~rkpr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt del1 k pc tc w Type-Bound Procedures a_t Source Code rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr","tags":"","loc":"type/rkpr.html"},{"title":"srk – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Inherits type~~srk~~InheritsGraph type~srk srk type~pure_compound pure_compound type~srk->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k pc tc w Type-Bound Procedures a_t Source Code srk Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ), private :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk","tags":"","loc":"type/srk.html"},{"title":"mix – Multicomponent Equations of State ","text":"type, public :: mix Inherits type~~mix~~InheritsGraph type~mix mix type~pure_compound pure_compound type~mix->type~pure_compound compounds type~kij_constant kij_constant type~mix->type~kij_constant kij_calculator type~lij_constant lij_constant type~mix->type~lij_constant lij_calculator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables aij bij compounds kij_calculator kij_matrix lij_calculator Type-Bound Procedures get_aij Source Code mix Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) real(kind=wp), public, allocatable :: bij (:,:) class( pure_compound ), public, allocatable :: compounds (:) class( kij_constant ), public, allocatable :: kij_calculator real(kind=wp), public, allocatable :: kij_matrix (:,:) class( lij_constant ), public, allocatable :: lij_calculator Type-Bound Procedures procedure, public :: get_aij => aij public subroutine aij (self, T) Arguments Type Intent Optional Attributes Name class( mix ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K] Source Code type :: mix class ( pure_compound ), allocatable :: compounds (:) class ( kij_constant ), allocatable :: kij_calculator class ( lij_constant ), allocatable :: lij_calculator real ( wp ), allocatable :: kij_matrix (:, :) real ( wp ), allocatable :: aij (:, :) real ( wp ), allocatable :: bij (:, :) contains procedure :: get_aij => aij !procedure :: get_kij => kij end type mix","tags":"","loc":"type/mix.html"},{"title":"Rectangle – Multicomponent Equations of State ","text":"type, public :: Rectangle Contents Variables base height Type-Bound Procedures get_area Source Code Rectangle Components Type Visibility Attributes Name Initial real, public :: base real, public :: height Type-Bound Procedures procedure, public :: get_area => rectangle_area public subroutine rectangle_area (this, area) Arguments Type Intent Optional Attributes Name class( Rectangle ), intent(in) :: this real :: area Source Code type :: Rectangle real :: base , height contains procedure :: get_area => rectangle_area end type Rectangle","tags":"","loc":"type/rectangle.html"},{"title":"kij_constant – Multicomponent Equations of State ","text":"type, public :: kij_constant constant type Inherited by type~~kij_constant~~InheritedByGraph type~kij_constant kij_constant type~kij_exp_t kij_exp_t type~kij_exp_t->type~kij_constant type~mix mix type~mix->type~kij_constant kij_calculator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables kij Type-Bound Procedures get_kij Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: kij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_const public subroutine kij_const (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix","tags":"","loc":"type/kij_constant.html"},{"title":"kij_exp_t – Multicomponent Equations of State ","text":"type, public, extends( kij_constant ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Inherits type~~kij_exp_t~~InheritsGraph type~kij_exp_t kij_exp_t type~kij_constant kij_constant type~kij_exp_t->type~kij_constant Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables T_star dkij2dt2 dkijdt kij kij_0 kij_inf Type-Bound Procedures get_kij Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature Type-Bound Procedures procedure, public :: get_kij => kij_tdep public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix","tags":"","loc":"type/kij_exp_t.html"},{"title":"lij_constant – Multicomponent Equations of State ","text":"type, public :: lij_constant Inherited by type~~lij_constant~~InheritedByGraph type~lij_constant lij_constant type~mix mix type~mix->type~lij_constant lij_calculator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lij Source Code lij_constant Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: lij (:,:) Source Code type :: lij_constant real ( wp ), allocatable :: lij (:, :) end type lij_constant","tags":"","loc":"type/lij_constant.html"},{"title":"a_parameter – Multicomponent Equations of State","text":"public subroutine a_parameter(self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Contents Variables Tc Tr ac k Source Code a_parameter Variables Type Visibility Attributes Name Initial real(kind=8), public :: Tc real(kind=8), public :: Tr real(kind=8), public :: ac real(kind=8), public :: k Source Code subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter","tags":"","loc":"proc/a_parameter.html"},{"title":"aij – Multicomponent Equations of State","text":"public subroutine aij(self, T) Arguments Type Intent Optional Attributes Name class( mix ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K] Contents Variables a b da2dt2 dadt dkij2dt2 dkijdt i j kij kij_rule nc Source Code aij Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: a (:) real(kind=wp), public, allocatable :: b (:) real(kind=wp), public, allocatable :: da2dt2 (:) real(kind=wp), public, allocatable :: dadt (:) real(kind=wp), public, allocatable :: dkij2dt2 (:,:) real(kind=wp), public, allocatable :: dkijdt (:,:) integer, public :: i integer, public :: j real(kind=wp), public, allocatable :: kij (:,:) class( kij_constant ), public, pointer :: kij_rule integer, public :: nc Source Code subroutine aij ( self , T ) class ( mix ) :: self !! Mixture object real ( wp ), intent ( in ) :: T !! Temperature [K] class ( kij_constant ), pointer :: kij_rule real ( wp ), allocatable :: a (:) real ( wp ), allocatable :: dadt (:) real ( wp ), allocatable :: da2dt2 (:) real ( wp ), allocatable :: b (:) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , j , nc nc = size ( self % compounds ) allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) ! Calculate all the pure compounds atractive parameters at T do i = 1 , nc call self % compounds ( i )% a_t ( T ) a ( i ) = self % compounds ( i )% a dadt ( i ) = self % compounds ( i )% dadt da2dt2 ( i ) = self % compounds ( i )% da2dt2 b ( i ) = self % compounds ( i )% b end do ! Calculate the kij matrix associate ( kij_rule => self % kij_calculator ) select type ( kij_rule ) type is ( kij_constant ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) type is ( kij_exp_t ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) class default print * , \"Error\" end select self % kij_matrix = kij end associate allocate ( self % aij ( nc , nc )) do i = 1 , nc self % aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) end do end subroutine aij","tags":"","loc":"proc/aij.html"},{"title":"rectangle_area – Multicomponent Equations of State","text":"public subroutine rectangle_area(this, area) Arguments Type Intent Optional Attributes Name class( Rectangle ), intent(in) :: this real :: area Contents Source Code rectangle_area Source Code subroutine rectangle_area ( this , area ) class ( Rectangle ), intent ( in ) :: this real :: area area = this % base * this % height end subroutine rectangle_area","tags":"","loc":"proc/rectangle_area.html"},{"title":"select_figure – Multicomponent Equations of State","text":"public subroutine select_figure(this, obj) Arguments Type Intent Optional Attributes Name class(*), intent(inout), allocatable :: this integer, intent(in) :: obj Called by proc~~select_figure~~CalledByGraph proc~select_figure select_figure program~geometry geometry program~geometry->proc~select_figure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code select_figure Source Code subroutine select_figure ( this , obj ) class ( * ), allocatable , intent ( in out ) :: this integer , intent ( in ) :: obj select case ( obj ) case ( 1 ) allocate ( Rectangle :: this ) end select end subroutine select_figure","tags":"","loc":"proc/select_figure.html"},{"title":"kij_const – Multicomponent Equations of State","text":"public subroutine kij_const(self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix Contents Source Code kij_const Source Code subroutine kij_const ( self , T , kij , dkijdt , dkij2dt2 ) class ( kij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix kij = self % kij dkijdt = 0 * kij dkij2dt2 = 0 * kij end subroutine kij_const","tags":"","loc":"proc/kij_const.html"},{"title":"kij_tdep – Multicomponent Equations of State","text":"public subroutine kij_tdep(self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix Contents Variables T_star kij_0 kij_inf nc sp Source Code kij_tdep Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) real(kind=wp), public, allocatable :: kij_0 (:,:) real(kind=wp), public, allocatable :: kij_inf (:,:) integer, public :: nc integer, public :: sp (2) Source Code subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep","tags":"","loc":"proc/kij_tdep.html"},{"title":"quadratic – Multicomponent Equations of State","text":"public subroutine quadratic(nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix Contents Variables i j Source Code quadratic Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j Source Code subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic","tags":"","loc":"proc/quadratic.html"},{"title":"FUG_CALC – Multicomponent Equations of State","text":"public subroutine FUG_CALC(a, b, del1, T, P, V, phi) Uses constants proc~~fug_calc~~UsesGraph proc~fug_calc FUG_CALC module~constants constants proc~fug_calc->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi Calls proc~~fug_calc~~CallsGraph proc~fug_calc FUG_CALC proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fug_calc~~CalledByGraph proc~fug_calc FUG_CALC proc~vaporpressure VaporPressure proc~vaporpressure->proc~fug_calc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F F_2V F_N F_V RT Z Variables Type Visibility Attributes Name Initial real(kind=8), public :: F real(kind=8), public :: F_2V real(kind=8), public :: F_N real(kind=8), public :: F_V real(kind=8), public :: RT real(kind=8), public :: Z","tags":"","loc":"proc/fug_calc.html"},{"title":"VCALC – Multicomponent Equations of State","text":"public recursive subroutine VCALC(ITYP, a, b, del1, T, P, V) Uses constants proc~~vcalc~~UsesGraph proc~vcalc VCALC module~constants constants proc~vcalc->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V Calls proc~~vcalc~~CallsGraph proc~vcalc VCALC proc~vcalc->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vcalc~~CalledByGraph proc~vcalc VCALC proc~vcalc->proc~vcalc proc~vaporpressure VaporPressure proc~vaporpressure->proc~vcalc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AT AVAP DER F FIRST_RUN F_2V F_N F_V ITER PCALC VVAP ZETA ZETMAX ZETMIN del Source Code VCALC Variables Type Visibility Attributes Name Initial real(kind=8), public :: AT real(kind=8), public :: AVAP real(kind=8), public :: DER real(kind=8), public :: F logical, public :: FIRST_RUN real(kind=8), public :: F_2V real(kind=8), public :: F_N real(kind=8), public :: F_V integer, public :: ITER real(kind=8), public :: PCALC real(kind=8), public :: VVAP real(kind=8), public :: ZETA real(kind=8), public :: ZETMAX real(kind=8), public :: ZETMIN real(kind=8), public :: del Source Code recursive subroutine VCALC ( ITYP , a , b , del1 , T , P , V ) ! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use constants , only : RGAS integer , intent ( in ) :: ITYP ! Type of root desired 1 for liquid -1 for vapor real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( out ) :: V ! Internal variables integer :: ITER logical :: FIRST_RUN real ( 8 ) :: ZETMIN , ZETMAX , ZETA , F , F_V , F_2V , F_N , & PCALC , del , AT , DER , VVAP , AVAP FIRST_RUN = . TRUE . ITER = 0 ZETMIN = 0.D0 ZETMAX = . 99 D0 if ( ITYP . GT . 0 ) then ! Liquid estimate ZETA = . 5 D0 else ! Ideal gas estimate ZETA = MIN (. 5 D0 , b * P / ( RGAS * T )) end if del = 1.d0 do while ( abs ( del ) > 1 d - 10 ) V = b / ZETA ITER = ITER + 1 CALL vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) PCALC = RGAS * T * ( 1 / V - F_V ) if ( PCALC . GT . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = F - LOG ( V ) + V * P / ( T * RGAS ) DER = RGAS * T * ( F_2V + 1.d0 ) / b DEL = - ( PCALC - P ) / DER ZETA = ZETA + MAX ( MIN ( DEL , 0.1d0 ), - 0.1d0 ) if ( ZETA . GT . ZETMAX . OR . ZETA . LT . ZETMIN ) then ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end if end do if ( ITYP == 0 ) then VVAP = V AVAP = AT ! Calculate Liquid volume and It's energy call VCALC ( 1 , a , b , del1 , T , P , V ) call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) AT = F - LOG ( V ) + V * P / ( T * RGAS ) if ( AT . GT . AVAP ) V = VVAP end if end subroutine VCALC","tags":"","loc":"proc/vcalc.html"},{"title":"VaporPressure – Multicomponent Equations of State","text":"public recursive subroutine VaporPressure(a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Uses constants proc~~vaporpressure~~UsesGraph proc~vaporpressure VaporPressure module~constants constants proc~vaporpressure->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL Calls proc~~vaporpressure~~CallsGraph proc~vaporpressure VaporPressure proc~vaporpressure->proc~vaporpressure proc~fug_calc FUG_CALC proc~vaporpressure->proc~fug_calc proc~vcalc VCALC proc~vaporpressure->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vaporpressure~~CalledByGraph proc~vaporpressure VaporPressure proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables P Plast Pold T V dphi dphiold phi phiV Variables Type Visibility Attributes Name Initial real(kind=8), public :: P real(kind=8), public :: Plast real(kind=8), public :: Pold real(kind=8), public :: T real(kind=8), public :: V real(kind=8), public :: dphi = 0.d0 real(kind=8), public :: dphiold real(kind=8), public :: phi real(kind=8), public :: phiV","tags":"","loc":"proc/vaporpressure.html"},{"title":"get_Zc_OMa_OMb – Multicomponent Equations of State","text":"public subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb Called by proc~~get_zc_oma_omb~~CalledByGraph proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr_params_from_crit pr_params_from_crit proc~pr_params_from_crit->proc~get_zc_oma_omb proc~srk_params_from_crit srk_params_from_crit proc~srk_params_from_crit->proc~get_zc_oma_omb proc~pr_critical_from_params pr_critical_from_params proc~pr_critical_from_params->proc~get_zc_oma_omb proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~get_zc_oma_omb proc~srk_critical_from_params srk_critical_from_params proc~srk_critical_from_params->proc~get_zc_oma_omb proc~rkpr_critical_from_params rkpr_critical_from_params proc~rkpr_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables d1 y Source Code get_Zc_OMa_OMb Variables Type Visibility Attributes Name Initial real(kind=8), public :: d1 real(kind=8), public :: y Source Code subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) real ( 8 ), intent ( in ) :: del1 ! RKPR delta_1 parameter real ( 8 ), intent ( out ) :: Zc ! Critical compressibility factor real ( 8 ), intent ( out ) :: OMa ! real ( 8 ), intent ( out ) :: OMb ! real ( 8 ) :: d1 , y d1 = ( 1.d0 + del1 ** 2.d0 ) / ( 1.d0 + del1 ) y = 1.d0 + ( 2.d0 * ( 1.d0 + del1 )) ** ( 1.0d0 / 3.d0 ) + ( 4.d0 / ( 1.d0 + del1 )) ** ( 1.0d0 / 3 ) OMa = ( 3.d0 * y * y + 3.d0 * y * d1 + d1 ** 2.d0 + d1 - 1.0d0 ) / ( 3.d0 * y + d1 - 1.0d0 ) ** 2.d0 OMb = 1.d0 / ( 3.d0 * y + d1 - 1.0d0 ) Zc = y / ( 3.d0 * y + d1 - 1.0d0 ) end subroutine get_Zc_OMa_OMb","tags":"","loc":"proc/get_zc_oma_omb.html"},{"title":"getdel1 – Multicomponent Equations of State","text":"public subroutine getdel1(Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 Called by proc~~getdel1~~CalledByGraph proc~getdel1 getdel1 proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~getdel1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Z_old Zc aux d1 del1_old error y Source Code getdel1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: Z_old real(kind=8), public :: Zc real(kind=8), public :: aux real(kind=8), public :: d1 real(kind=8), public :: del1_old real(kind=8), public :: error = 1.d0 real(kind=8), public :: y Source Code subroutine getdel1 ( Zc_in , del1_ini , del1 ) real ( 8 ), intent ( in ) :: Zc_in real ( 8 ), intent ( in ) :: del1_ini real ( 8 ), intent ( out ) :: del1 real ( 8 ) :: d1 , y , del1_old , Zc , Z_old , aux , error = 1.d0 del1 = del1_ini d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Zc = y / ( 3 * y + d1 - 1.0d0 ) del1_old = del1 if ( Zc . gt . Zc_in ) then del1 = 1.01 * del1 else del1 = 0.99 * del1 end if do while ( error >= 1.0d-6 ) d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Z_old = Zc Zc = y / ( 3 * y + d1 - 1.0d0 ) aux = del1 del1 = del1 - ( Zc - Zc_in ) * ( del1 - del1_old ) / ( Zc - Z_old ) del1_old = aux error = abs ( Zc - Zc_in ) end do end subroutine getdel1","tags":"","loc":"proc/getdel1.html"},{"title":"pr_critical_from_params – Multicomponent Equations of State","text":"public subroutine pr_critical_from_params(ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~pr_critical_from_params~~CallsGraph proc~pr_critical_from_params pr_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb Zc al be del1 ga Source Code pr_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: del1 = 1.0D0+sqrt(2.0) real(kind=8), public :: ga Source Code subroutine pr_critical_from_params ( ac , b , m , R , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0D0 + sqrt ( 2.0 ) real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * R * b ) Pc = OMb * R * Tc / b Vceos = Zc * R * Tc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine pr_critical_from_params","tags":"","loc":"proc/pr_critical_from_params.html"},{"title":"pr_params_from_crit – Multicomponent Equations of State","text":"public subroutine pr_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Calls proc~~pr_params_from_crit~~CallsGraph proc~pr_params_from_crit pr_params_from_crit proc~get_zc_oma_omb get_Zc_OMa_OMb proc~pr_params_from_crit->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb RT Vceos Zc del1 Source Code pr_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: RT real(kind=8), public :: Vceos real(kind=8), public :: Zc real(kind=8), public :: del1 = 1.0d0+sqrt(2.d0) Source Code subroutine pr_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc ! Critical temperature real ( 8 ), intent ( in ) :: Pc ! Critical pressure real ( 8 ), intent ( in ) :: w ! Accentric factor real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: ac ! ac parameter real ( 8 ), intent ( out ) :: b ! Covolume real ( 8 ), intent ( out ) :: m ! Constant to calculate a(T) ! Internal varibles real ( 8 ) :: del1 = 1.0d0 + sqrt ( 2.d0 ) ! delta_1 for PR since the parameters are calculated based on the RKPR method real ( 8 ) :: OMa , OMb , Zc , Vceos ! real ( 8 ) :: RT ! R*T product RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc ! m constant to calculate a depending on temperature if ( w <= 0.491 ) then ! m from PR m = 0.37464 + 1.54226 * w - 0.26992 * w ** 2 end if if ( w > 0.491 ) then ! PR78 m = 0.379642 + 1.48503 * w - 0.164423 * w ** 2 + 0.016666 * w ** 3 end if end subroutine pr_params_from_crit","tags":"","loc":"proc/pr_params_from_crit.html"},{"title":"rkpr_critical_from_params – Multicomponent Equations of State","text":"public subroutine rkpr_critical_from_params(ac, b, del1, k, Tc, Pc, w, Vceos) Uses constants proc~~rkpr_critical_from_params~~UsesGraph proc~rkpr_critical_from_params rkpr_critical_from_params module~constants constants proc~rkpr_critical_from_params->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~rkpr_critical_from_params~~CallsGraph proc~rkpr_critical_from_params rkpr_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~rkpr_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb Zc al be ga Source Code rkpr_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: ga Source Code subroutine rkpr_critical_from_params ( ac , b , del1 , k , Tc , Pc , w , Vceos ) use constants real ( 8 ), intent ( in ) :: ac ! ac parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: del1 ! delta_1 parameter real ( 8 ), intent ( in ) :: k ! k parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! Accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume real ( 8 ) :: Zc , OMa , OMb , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = A1 * Zc + A0 be = B1 * Zc + B0 ga = C1 * Zc + C0 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine rkpr_critical_from_params","tags":"","loc":"proc/rkpr_critical_from_params.html"},{"title":"rkpr_params_from_crit – Multicomponent Equations of State","text":"public subroutine rkpr_params_from_crit(Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate “a” with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 Calls proc~~rkpr_params_from_crit~~CallsGraph proc~rkpr_params_from_crit rkpr_params_from_crit d d proc~rkpr_params_from_crit->d proc~getdel1 getdel1 proc~rkpr_params_from_crit->proc~getdel1 proc~get_zc_oma_omb get_Zc_OMa_OMb proc~rkpr_params_from_crit->proc~get_zc_oma_omb proc~vaporpressure VaporPressure proc~rkpr_params_from_crit->proc~vaporpressure proc~vaporpressure->proc~vaporpressure proc~fug_calc FUG_CALC proc~vaporpressure->proc~fug_calc proc~vcalc VCALC proc~vaporpressure->proc~vcalc proc~vdwg_derivs vdWg_Derivs proc~fug_calc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vcalc->proc~vdwg_derivs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb Pold Pv Pv_spec RHOL RHOV RHOld RT Tr Trho Zc a dc del1_old del1_spec del1ini delta_del1 delta_k oldk phiL rhoL_spec Source Code rkpr_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Pold real(kind=8), public :: Pv logical, public :: Pv_spec real(kind=8), public :: RHOL real(kind=8), public :: RHOV real(kind=8), public :: RHOld real(kind=8), public :: RT real(kind=8), public :: Tr real(kind=8), public :: Trho real(kind=8), public :: Zc real(kind=8), public :: a real(kind=8), public :: dc real(kind=8), public :: del1_old logical, public :: del1_spec real(kind=8), public :: del1ini real(kind=8), public :: delta_del1 real(kind=8), public :: delta_k real(kind=8), public :: oldk real(kind=8), public :: phiL logical, public :: rhoL_spec Source Code subroutine rkpr_params_from_crit ( & Tc , Pc , w , R , ac , b , k , del1 , Vceos , T , Pvdat , RhoLsat & ) !! Get the RKPR EOS parameters from the substance critical properties. ! Input real ( 8 ), intent ( in ) :: Tc !! Critical temperature real ( 8 ), intent ( in ) :: Pc !! Critical pressure real ( 8 ), intent ( in ) :: w !! accentric factor real ( 8 ), intent ( in ) :: R !! Gas constant ! Optional cases where extra specifications are made real ( 8 ), intent ( inout ), optional :: del1 !! delta_1 real ( 8 ), intent ( inout ), optional :: Vceos !! Critical volume at specification real ( 8 ), intent ( in ), optional :: T !! Temperature used to either estimate k or del1 real ( 8 ), intent ( inout ), optional :: Pvdat !! Vapor pressure used to estimate k real ( 8 ), intent ( in ), optional :: RhoLsat !! Saturation density used to estimate del1 !------------------------------------------------------------------------ real ( 8 ), intent ( out ) :: ac !! ac parameter real ( 8 ), intent ( out ) :: b !! covolume real ( 8 ), intent ( out ) :: k !! k to calculate \"a\" with ac and T real ( 8 ) :: OMa , OMb , Zc , RT , del1ini , dc , Tr , & a , Pv , RHOL , RHOV , phiL , delta_k , Pold , oldk , & Trho , RHOld , del1_old , delta_del1 logical :: del1_spec , Pv_spec , rhoL_spec del1_spec = . false . Pv_spec = . false . rhoL_spec = . false . if ( present ( del1 )) then del1_spec = . true . !print *, \"Specified del1\" end if if ( present ( T )) then if ( present ( Pvdat )) then Pv_spec = . true . !print *, \"Specified Pv\" end if end if if ( present ( T )) then if ( present ( RhoLsat )) then rhoL_spec = . true . !print *, \"Specified RhoLsat\" end if end if ! Initialize delta_1 and get the value that statisfies the Zc ! condition ! ----------------------------------------------------------------------- RT = R * Tc if ( present ( Vceos )) then ! Usual specification with Vceos Zc = Pc * Vceos / RT del1ini = D ( 1 ) + D ( 2 ) * ( D ( 3 ) - Zc ) ** D ( 4 ) + D ( 5 ) * ( D ( 3 ) - Zc ) ** D ( 6 ) call getdel1 ( Zc , del1ini , del1 ) end if if ( rhoL_spec ) then Trho = T / Tc del1 = 2.0 ! initial value RHOld = 0.d0 end if ! Calculate the inbetween parameters and finally get ac and b ! ----------------------------------------------------------------------- 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc ! Obtain the k parameter ! ----------------------------------------------------------------------- dc = Pc / Zc / RT Vceos = 1.0d0 / dc ! initial guess for k parameter k = ( A1 * Zc + A0 ) * w ** 2 + ( B1 * Zc + B0 ) * w + ( C1 * Zc + C0 ) a = ac * ( 3 / ( 2 + Tr )) ** k if ( del1_spec ) then Vceos = Zc * RT / Pc end if if ( Pv_spec ) then ! added 29/06/2013 in order to allow for better reproductions of Pv curves Tr = T / Tc else Tr = 0.7d0 Pvdat = Pc * 10 **- ( 1.0d0 + w ) end if ! Find the value of k that fits with the expected Pv call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) if ( Pv > Pvdat ) then delta_k = 0.1 else delta_k = - 0.1 end if do while ( abs ( Pv - Pvdat ) / Pvdat > 0.005 ) Pold = Pv oldk = k k = k + delta_k a = ac * ( 3 / ( 2 + Tr )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) delta_k = - ( Pv - Pvdat ) * ( k - oldk ) / ( Pv - Pold ) end do if ( rhoL_spec ) then ! November 2011 for RKPR specifying T, RHOLsat if ( abs ( Trho - 0.70 ) > 1.d-2 ) then ! get calculated RHOL when Trho is no 0.70 Pvdat = Pc * 10 **- (( 1. / Trho - 1 d0 ) * 7 * ( 1.0D0 + w ) / 3 ) a = ac * ( 3 / ( 2 + Trho )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Trho , Pvdat , Pv , RHOL , RHOV , phiL ) end if if ( RHOld == 0.d0 ) then del1_old = del1 ! condition for the strange case that del1=2 is solution if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) del1 = 2.1 else delta_del1 = - ( RHOL - RhoLsat ) * ( del1 - del1_old ) / ( RHOL - RHOld ) del1_old = del1 del1 = del1 + delta_del1 end if RHOld = RHOL if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) go to 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc end if end subroutine rkpr_params_from_crit","tags":"","loc":"proc/rkpr_params_from_crit.html"},{"title":"srk_critical_from_params – Multicomponent Equations of State","text":"public subroutine srk_critical_from_params(ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Calls proc~~srk_critical_from_params~~CallsGraph proc~srk_critical_from_params srk_critical_from_params proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_critical_from_params->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb Zc al be del1 ga Source Code srk_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: del1 = 1.0d0 real(kind=8), public :: ga Source Code subroutine srk_critical_from_params ( ac , b , m , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0d0 real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = - 0.175 be = 1.574 ga = 0.48 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine srk_critical_from_params","tags":"","loc":"proc/srk_critical_from_params.html"},{"title":"srk_params_from_crit – Multicomponent Equations of State","text":"public subroutine srk_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Calls proc~~srk_params_from_crit~~CallsGraph proc~srk_params_from_crit srk_params_from_crit proc~get_zc_oma_omb get_Zc_OMa_OMb proc~srk_params_from_crit->proc~get_zc_oma_omb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables OMa OMb RT Vceos Zc del1 Source Code srk_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: RT real(kind=8), public :: Vceos real(kind=8), public :: Zc real(kind=8), public :: del1 = 1.0D0 Source Code subroutine srk_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: Pc real ( 8 ), intent ( out ) :: w real ( 8 ), intent ( in ) :: R real ( 8 ), intent ( out ) :: ac real ( 8 ), intent ( out ) :: b real ( 8 ), intent ( out ) :: m real ( 8 ) :: del1 = 1.0D0 real ( 8 ) :: OMa , OMb , Zc , Vceos real ( 8 ) :: RT RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc m = 0.48 + 1.574 * w - 0.175 * w ** 2 end subroutine srk_params_from_crit","tags":"","loc":"proc/srk_params_from_crit.html"},{"title":"vdWg_Derivs – Multicomponent Equations of State","text":"public subroutine vdWg_Derivs(a, b, del1, T, V, F, F_V, F_2V, F_N) Uses constants proc~~vdwg_derivs~~UsesGraph proc~vdwg_derivs vdWg_Derivs module~constants constants proc~vdwg_derivs->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N Called by proc~~vdwg_derivs~~CalledByGraph proc~vdwg_derivs vdWg_Derivs proc~fug_calc FUG_CALC proc~fug_calc->proc~vdwg_derivs proc~vcalc VCALC proc~vcalc->proc~vdwg_derivs proc~vcalc->proc~vcalc proc~vaporpressure VaporPressure proc~vaporpressure->proc~fug_calc proc~vaporpressure->proc~vcalc proc~vaporpressure->proc~vaporpressure proc~rkpr_params_from_crit rkpr_params_from_crit proc~rkpr_params_from_crit->proc~vaporpressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ATT ATT2V ATTV C ETA REP REP2V REPV SUMC SUMD aRT Variables Type Visibility Attributes Name Initial real(kind=8), public :: ATT real(kind=8), public :: ATT2V real(kind=8), public :: ATTV real(kind=8), public :: C real(kind=8), public :: ETA real(kind=8), public :: REP real(kind=8), public :: REP2V real(kind=8), public :: REPV real(kind=8), public :: SUMC real(kind=8), public :: SUMD real(kind=8), public :: aRT","tags":"","loc":"proc/vdwg_derivs.html"},{"title":"constants – Multicomponent Equations of State","text":"Used by module~~constants~~UsedByGraph module~constants constants module~cubic_eos cubic_eos module~cubic_eos->module~constants module~mixing_rules mixing_rules module~cubic_eos->module~mixing_rules proc~vdwg_derivs vdWg_Derivs proc~vdwg_derivs->module~constants module~mixing_rules->module~constants module~converter converter module~converter->module~constants proc~vcalc VCALC proc~vcalc->module~constants proc~rkpr_critical_from_params rkpr_critical_from_params proc~rkpr_critical_from_params->module~constants proc~fug_calc FUG_CALC proc~fug_calc->module~constants module~rkpr rkpr module~rkpr->module~constants proc~vaporpressure VaporPressure proc~vaporpressure->module~constants module~mixture mixture module~mixture->module~constants module~mixture->module~cubic_eos module~mixture->module~mixing_rules Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables A0 A1 B0 B1 C0 C1 Dfit ERRMAX RGAS wp Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: A0 = 0.0017 real(kind=wp), public, parameter :: A1 = -2.4407 real(kind=wp), public, parameter :: B0 = 1.9681 real(kind=wp), public, parameter :: B1 = 7.4513 real(kind=wp), public, parameter :: C0 = -2.7238 real(kind=wp), public, parameter :: C1 = 12.504 real(kind=wp), public, dimension(6) :: Dfit = [0.428363, 18.496215, 0.338426, 0.660, 789.723105, 2.512392] real(kind=wp), public, parameter :: ERRMAX = 1.D-8 real(kind=wp), public, parameter :: RGAS = 0.08314472d0 integer, public, parameter :: wp = 8","tags":"","loc":"module/constants.html"},{"title":"cubic_eos – Multicomponent Equations of State","text":"Module that encompass the calculations of the residual Helmholtz energy\nand related properties like fugacity coefficents. Uses mixing_rules constants module~~cubic_eos~~UsesGraph module~cubic_eos cubic_eos module~constants constants module~cubic_eos->module~constants module~mixing_rules mixing_rules module~cubic_eos->module~mixing_rules module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~cubic_eos~~UsedByGraph module~cubic_eos cubic_eos module~mixture mixture module~mixture->module~cubic_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types pr pure_compound rkpr srk Subroutines a_parameter Derived Types type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public :: pure_compound Generic EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter Subroutines public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate","tags":"","loc":"module/cubic_eos.html"},{"title":"mixture – Multicomponent Equations of State","text":"Uses cubic_eos mixing_rules constants module~~mixture~~UsesGraph module~mixture mixture module~constants constants module~mixture->module~constants module~cubic_eos cubic_eos module~mixture->module~cubic_eos module~mixing_rules mixing_rules module~mixture->module~mixing_rules module~cubic_eos->module~constants module~cubic_eos->module~mixing_rules module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types mix Subroutines aij Derived Types type, public :: mix Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) real(kind=wp), public, allocatable :: bij (:,:) class( pure_compound ), public, allocatable :: compounds (:) class( kij_constant ), public, allocatable :: kij_calculator real(kind=wp), public, allocatable :: kij_matrix (:,:) class( lij_constant ), public, allocatable :: lij_calculator Type-Bound Procedures procedure, public :: get_aij => aij Subroutines public subroutine aij (self, T) Arguments Type Intent Optional Attributes Name class( mix ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K]","tags":"","loc":"module/mixture.html"},{"title":"rkpr – Multicomponent Equations of State","text":"Uses constants module~~rkpr~~UsesGraph module~rkpr rkpr module~constants constants module~rkpr->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/rkpr.html"},{"title":"g – Multicomponent Equations of State","text":"Used by module~~g~~UsedByGraph module~g g program~geometry geometry program~geometry->module~g Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi Derived Types Rectangle Subroutines rectangle_area select_figure Variables Type Visibility Attributes Name Initial real, public :: pi = 3.1415926535897931 Derived Types type, public :: Rectangle Components Type Visibility Attributes Name Initial real, public :: base real, public :: height Type-Bound Procedures procedure, public :: get_area => rectangle_area Subroutines public subroutine rectangle_area (this, area) Arguments Type Intent Optional Attributes Name class( Rectangle ), intent(in) :: this real :: area public subroutine select_figure (this, obj) Arguments Type Intent Optional Attributes Name class(*), intent(inout), allocatable :: this integer, intent(in) :: obj","tags":"","loc":"module/g.html"},{"title":"mixing_rules – Multicomponent Equations of State","text":"Module that contains the available mixing rules to be used. Uses constants module~~mixing_rules~~UsesGraph module~mixing_rules mixing_rules module~constants constants module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mixing_rules~~UsedByGraph module~mixing_rules mixing_rules module~cubic_eos cubic_eos module~cubic_eos->module~mixing_rules module~mixture mixture module~mixture->module~mixing_rules module~mixture->module~cubic_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types kij_constant kij_exp_t lij_constant Subroutines kij_const kij_tdep quadratic Derived Types type, public :: kij_constant constant type Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: kij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_const type, public, extends( kij_constant ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature Type-Bound Procedures procedure, public :: get_kij => kij_tdep type, public :: lij_constant Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: lij (:,:) Subroutines public subroutine kij_const (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix public subroutine quadratic (nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix","tags":"","loc":"module/mixing_rules.html"},{"title":"parameters – Multicomponent Equations of State","text":"Uses iso_fortran_env module~~parameters~~UsesGraph module~parameters parameters iso_fortran_env iso_fortran_env module~parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Tc a b dc del1 Variables Type Visibility Attributes Name Initial real(kind=8), public, save :: Tc real(kind=8), public, save :: a real(kind=8), public, save :: b real(kind=8), public, save :: dc real(kind=8), public, save :: del1","tags":"","loc":"module/parameters.html"},{"title":"converter – Multicomponent Equations of State","text":"Uses iso_fortran_env constants module~~converter~~UsesGraph module~converter converter iso_fortran_env iso_fortran_env module~converter->iso_fortran_env module~constants constants module~converter->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines FUG_CALC VCALC VaporPressure get_Zc_OMa_OMb getdel1 pr_critical_from_params pr_params_from_crit rkpr_critical_from_params rkpr_params_from_crit srk_critical_from_params srk_params_from_crit vdWg_Derivs Subroutines public subroutine FUG_CALC (a, b, del1, T, P, V, phi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi public recursive subroutine VCALC (ITYP, a, b, del1, T, P, V) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V public recursive subroutine VaporPressure (a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL public subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb public subroutine getdel1 (Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 public subroutine pr_critical_from_params (ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine pr_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine rkpr_critical_from_params (ac, b, del1, k, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine rkpr_params_from_crit (Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate “a” with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 public subroutine srk_critical_from_params (ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine srk_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine vdWg_Derivs (a, b, del1, T, V, F, F_V, F_2V, F_N) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N","tags":"","loc":"module/converter.html"},{"title":"geometry – Multicomponent Equations of State","text":"Uses g program~~geometry~~UsesGraph program~geometry geometry module~g g program~geometry->module~g Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~geometry~~CallsGraph program~geometry geometry proc~select_figure select_figure program~geometry->proc~select_figure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables area figure Source Code geometry Variables Type Attributes Name Initial real :: area class(*), allocatable :: figure Source Code program geometry ! for both types in a single function use g class ( * ), allocatable :: figure real :: area call select_figure ( figure , 1 ) select type ( figure ) type is ( Rectangle ) figure % base = 2 figure % height = 3 call figure % get_area ( area ) end select print * , '' end program geometry","tags":"","loc":"program/geometry.html"},{"title":"main – Multicomponent Equations of State","text":"Uses json_module program~~main~~UsesGraph program~main main json_module json_module program~main->json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables found i id json_data kij kijs n name z Source Code main Variables Type Attributes Name Initial logical :: found integer :: i character(len=50) :: id type(json_file) :: json_data real(kind=8), allocatable :: kij (:) real(kind=8), allocatable :: kijs (:,:) integer :: n character(len=:), allocatable :: name real(kind=8), allocatable :: z (:) Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"program/main.html"}]}