var tipuesearch = {"pages":[{"title":" fedebenelli/rkpr ","text":"fedebenelli/rkpr Fortran program for the calculation of the residual Helmholtz Energy using the\nRKPR EoS (hence, PR and SRK are also included). Developer Info Federico Benelli Doctoral student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"constants.f90 – fedebenelli/rkpr","text":"Contents Modules constants Source Code constants.f90 Source Code module constants implicit none integer , parameter :: wp = 8 real ( wp ), parameter :: RGAS = 0.08314472d0 real ( wp ), parameter :: A0 = 0.0017 , B0 = 1.9681 , C0 = - 2.7238 real ( wp ), parameter :: A1 = - 2.4407 , B1 = 7.4513 , C1 = 1 2.504 real ( wp ), dimension ( 6 ) :: D = [ 0.428363 , 1 8.496215 , 0.338426 , & 0.660 , 78 9.723105 , 2.512392 ] real ( wp ), parameter :: ERRMAX = 1.D-8 end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"cubic_eos.f90 – fedebenelli/rkpr","text":"Contents Modules cubic_eos Source Code cubic_eos.f90 Source Code module cubic_eos !! Module that encompass the calculations of the residual Helmholtz energy !! and related properties like fugacity coefficents. use constants implicit none contains subroutine kij_tdep ( T , kij , dkijdt , dkij2dt2 ) !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module use mixture , only : nc , kij_0 , kij_inf , T_star implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: kij ( nc , nc ) !! Binary interaction parameter matrix real ( wp ), intent ( out ) :: dkijdt ( nc , nc ) !! Binary interaction parameter first derivative with T matrix real ( wp ), intent ( out ) :: dkij2dt2 ( nc , nc ) !! Binary interaction parameter second derivative with T matrix integer :: i do i = 1 , nc kij (: i - 1 , i ) = kij_inf (: i - 1 , i ) + kij_0 (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkijdt (: i - 1 , i ) = - kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkij2dt2 (: i - 1 , i ) = kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) ** 2 * exp ( - T / T_star (: i - 1 , i )) end do end subroutine kij_tdep subroutine aTder ( T , a , dadT , dadT2 ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. use mixture , only : nmodel , ac , k , tc , nc real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: a ( nc ) !! Atractive parameter at T real ( wp ), intent ( out ) :: dadT ( nc ) !! First deritvative with T real ( wp ), intent ( out ) :: dadT2 ( nc ) !! Second derivative with T real ( wp ) :: Tr ( nc ) ! Reduced temperature Tr = T / Tc if ( nmodel <= 2 ) then ! SRK and PR a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) else if ( nmodel == 3 ) then ! RKPR EOS a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder subroutine aijTder ( T , aij , daijdT , daij2dT2 ) !! Calculate the binary atractive term matrix use mixture , only : nc , ntdep , kij , kij_0 , lij , ncomb use mixing_rules , only : quadratic implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Atractive binary terms matrix real ( wp ), intent ( out ) :: daijdT ( nc , nc ) !! Atractive binary terms matrix first derivative with temperature real ( wp ), intent ( out ) :: daij2dT2 ( nc , nc ) !! Atractive binary terms matrix second derivative with temperature real ( wp ) :: dkijdt ( nc , nc ), dkij2dt2 ( nc , nc ) ! kij T derivatives real ( wp ) :: a ( nc ), dadT ( nc ), da2dT2 ( nc ) ! Atractive parameter and T derivatives real ( wp ) :: b ( nc ), bij ( nc , nc ) ! Repulsive parameter (just to use as input in subroutine) b = 0 ! Here only the aij for the mixture, so there is no need to use the real b select case ( ntdep ) case ( 1 ) ! Kij exponential temperature dependance call kij_tdep ( T , kij , dkijdt , dkij2dt2 ) case default kij = kij_0 dkijdt = 0 dkij2dt2 = 0 end select ! Calculate pure compound atractive parameters at T call aTder ( T , a , dadT , da2dT2 ) ! Apply combining rule select case ( ncomb ) case default call quadtratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , & lij , aij , daijdt , daij2dt2 , bij ) end select end subroutine aijTder subroutine amixTnder ( nc , T , n , a , dadni , da2dniT2 , da2dnij2 , dadT , da2dT2 ) !! Atractive parameter of a mixture and it's derivatives integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( in ) :: n ( nc ) !! Matrix with number of moles real ( wp ), intent ( out ) :: a !! Mixture atractive parameter real ( wp ), intent ( out ) :: dadni ( nc ) !! Atractive parameter first derivative with number of moles real ( wp ), intent ( out ) :: da2dniT2 ( nc ) !! Atractive parameter second derivative with moles and Tempeature real ( wp ), intent ( out ) :: da2dnij2 ( nc , nc ) !! Atractive parameter second derivative with number of moles real ( wp ), intent ( out ) :: dadT ( nc ) !! Atractive parameter first derivative with Tempeature real ( wp ), intent ( out ) :: da2dT2 ( nc ) !! Atractive parameter first derivative with Tempeature real ( wp ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( wp ) :: aux , aux2 integer :: i , j ! TODO: An already calculated aij matrix could be the input call aijTder ( T , aij , daijdT , daijdT2 ) a = 0.0_wp dadT = 0.0_wp da2dT2 = 0.0_wp do i = 1 , nc aux = 0.0_wp aux2 = 0.0_wp dadni ( i ) = 0.0_wp da2dniT2 ( i ) = 0.0_wp do j = 1 , nc dadni ( i ) = dadni ( i ) + 2 * n ( j ) * aij ( i , j ) da2dniT2 ( i ) = da2dniT2 ( i ) + 2 * n ( j ) * daijdT ( i , j ) da2dnij2 ( i , j ) = 2 * aij ( i , j ) aux = aux + n ( j ) * aij ( i , j ) aux2 = aux2 + n ( j ) * daijdT2 ( i , j ) end do a = a + n ( i ) * aux dadT = dadT + n ( i ) * da2dniT2 ( i ) / 2 da2dT2 = da2dT2 + n ( i ) * aux2 end do end subroutine amixTnder subroutine d1nder ( nc , n , d1 , d1_mix , dD1dni , dD12dnij2 ) !! Delta_1 of the mixture and compositional derivatives. integer , intent ( in ) :: nc !! Number of components. real ( wp ), intent ( in ) :: n ( nc ) !! Array of mole numbers for each component. real ( wp ), intent ( in ) :: d1 ( nc ) !! Array of delta 1 parameters for each component. real ( wp ), intent ( out ) :: d1_mix !! ?? real ( wp ), intent ( out ) :: dD1dni ( nc ) !! delta1 parameter first derivative with composition. real ( wp ), intent ( out ) :: dD12dnij2 ( nc , nc ) !! delta1 parameter second derivative with composition. integer :: i , j real ( wp ) :: totn ! Total number of moles d1_mix = 0.0_wp do i = 1 , nc d1_mix = d1_mix + n ( i ) * d1 ( i ) end do totn = sum ( n ) d1_mix = d1_mix / totn do i = 1 , nc dD1dni ( i ) = ( d1 ( i ) - d1_mix ) / totn do j = 1 , nc dD12dnij2 ( i , j ) = ( 2.0_wp * d1_mix - d1 ( i ) - d1 ( j )) / totn ** 2 end do end do end subroutine d1nder subroutine Bmixnder ( nc , n , bij , B_mix , dBdni , dB2dnij2 ) !! Repulsive parameter of the mixture and it's compositional derivatives. integer , intent ( in ) :: nc real ( wp ), intent ( in ) :: n ( nc ) real ( wp ), intent ( in ) :: bij ( nc , nc ) real ( wp ), intent ( out ) :: B_mix real ( wp ), intent ( out ) :: dBdni ( nc ) real ( wp ), intent ( out ) :: dB2dnij2 ( nc , nc ) real ( wp ) :: totn , aux ( nc ) integer :: i , j totn = sum ( n ) B_mix = 0.0_wp aux = 0.0_wp do i = 1 , nc do j = 1 , nc aux ( i ) = aux ( i ) + n ( j ) * bij ( i , j ) end do B_mix = B_mix + n ( i ) * aux ( i ) end do B_mix = B_mix / totn do i = 1 , nc dBdni ( i ) = ( 2 * aux ( i ) - B_mix ) / totn do j = 1 , i dB2dnij2 ( i , j ) = ( 2 * bij ( i , j ) - dBdni ( i ) - dBdni ( j )) / totn dB2dnij2 ( j , i ) = dB2dnij2 ( i , j ) end do end do end subroutine Bnder subroutine helmholtz_energy ( nc , ND , NT , n , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: ND , NT real ( wp ), intent ( in ) :: n ( nc ) !! Number of moles real ( wp ), intent ( in ) :: V !! real ( wp ), intent ( in ) :: T real ( wp ), intent ( out ) :: Ar real ( wp ), intent ( out ) :: ArV real ( wp ), intent ( out ) :: ArTV real ( wp ), intent ( out ) :: ArV2 real ( wp ), intent ( out ) :: Arn ( nc ) real ( wp ), intent ( out ) :: ArVn ( nc ) real ( wp ), intent ( out ) :: ArTn ( nc ) real ( wp ), intent ( out ) :: Arn2 ( nc , nc ) real ( wp ) :: dBi ( nc ), dBij ( nc , nc ) real ( wp ) :: dDi ( nc ), dDij ( nc , nc ), dDiT ( nc ) real ( wp ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( wp ) :: Kij ( nco , nco ) real ( wp ) :: ac ( nco ), b ( nco ), del1 ( nco ), rm ( nco ) TOTN = sum ( rn ) D1 = del1 ( 1 ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( ncomb . lt . 2 ) then call amixTnder ( nc , T , n , a , dadni , da2dniT2 , da2dnij2 , dadT , da2dT2 ) call Bmixnder ( nc , rn , Bmix , dBi , dBij ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NT,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = RGAS * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) gv = RGAS * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = RGAS * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) fB = - ( f + V * fv ) / Bmix ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = RGAS * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) if ( ND . EQ . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES IF ( NT . EQ . 1 ) THEN ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) end do END IF end subroutine helmholtz_energy subroutine helmholtz_energy_RKPR ( nco , NDE , NTD , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Calculate the reduced residual Helmholtz Energy and it's derivatives with the RKPR EOS IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) PARAMETER ( RGAS = 0.08314472d0 ) dimension :: rn ( nco ), Arn ( nco ), ArVn ( nco ), ArTn ( nco ), Arn2 ( nco , nco ) dimension dBi ( nco ), dBij ( nco , nco ), dD1i ( nco ), dD1ij ( nco , nco ) dimension dDi ( nco ), dDij ( nco , nco ), dDiT ( nco ) dimension aij ( nco , nco ), daijdT ( nco , nco ), daijdT2 ( nco , nco ) COMMON / rule / ncomb nc = nco TOTN = sum ( rn ) call DELTAnder ( nc , rn , D1 , dD1i , dD1ij ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( ncomb . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NTD,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if !  The f's and g's used here are for Ar, not F (reduced Ar) !  This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = RGAS * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = RGAS * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = RGAS * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * Bmix ) + 2 / ( V + D2 * Bmix ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * Bmix ) ** 2 + 2 * D2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * Bmix ) ** 2 + 2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * Bmix )) / ( 1 + D1 ) ** 3 + Bmix * ( - 1 / ( V + D1 * Bmix ) ** 2 & + 4 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = RGAS * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) - D * fD1 * dD1i ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) - D * fVD1 * dD1i ( i ) if ( NDE . EQ . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES IF ( NTD . EQ . 1 ) THEN ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) - dDdT * fD1 * dD1i ( i ) end do END IF end subroutine helmholtz_energy_RKPR end module cubic_eos","tags":"","loc":"sourcefile/cubic_eos.f90.html"},{"title":"mixture.f90 – fedebenelli/rkpr","text":"Contents Modules datatypes mixture Source Code mixture.f90 Source Code module datatypes use constants implicit none type mix integer :: nmodel !! Model to use integer :: nc !! Number of components integer :: ntdep !! Temperature dependence integer :: ncomb !! Combining rule character ( len = :), dimension (:), allocatable :: names !! Components names real ( wp ), dimension (:), allocatable :: n !! Number of moles ! Properties real ( wp ), dimension (:), allocatable :: tc !! Critical Temperatures real ( wp ), dimension (:), allocatable :: pc !! Critical Pressures real ( wp ), dimension (:), allocatable :: dc !! Critical Densities (from EOS) real ( wp ), dimension (:), allocatable :: w !! Accentric factors ! EOS parameters real ( wp ), dimension (:), allocatable :: ac !! EOS atractive parameter real ( wp ), dimension (:), allocatable :: b !! EOS repulsive parameter real ( wp ), dimension (:), allocatable :: del1 !! EOS delta_1 real ( wp ), dimension (:), allocatable :: k !! k parameter to calculate the a parameter ! Mixing parameters real ( wp ), dimension (:, :), allocatable :: kij !! Kij matrix real ( wp ), dimension (:, :), allocatable :: kij0 !! Kij standard real ( wp ), dimension (:, :), allocatable :: kij_inf !! Kij at infinite temperature real ( wp ), dimension (:, :), allocatable :: T_star !! Reference temperature for temperature dependent Kij real ( wp ), dimension (:, :), allocatable :: lij !! lij matrix real ( wp ), dimension (:, :), allocatable :: aij !! EOS atractive parameter matrix end type mix type compound !! real ( wp ) :: tc real ( wp ) :: pc real ( wp ) :: ac real ( wp ) :: b real ( wp ) :: w real ( wp ) :: k end type compound end module datatypes module mixture !! Module to represent a mixture of fluids, it's used to save the !! multiple component's properties to be used by different subroutines. !! It also includes a set of subroutines to read the data and save it !! in the module. !! System of units: This units are asumed, if the user wants to use another !! system, the RGAS constant should be changed at the module `constants` !! !! - Volume: Liter !! - Pressure: bar !! - Temperature: Kelvin use constants implicit none integer :: nmodel !! Model to use integer :: nc !! Number of components integer :: ntdep !! Temperature dependence integer :: ncomb !! Combining rule character ( len = :), dimension (:), allocatable :: names !! Components names real ( wp ), dimension (:), allocatable :: n !! Number of moles ! Properties real ( wp ), dimension (:), allocatable :: tc !! Critical Temperatures real ( wp ), dimension (:), allocatable :: pc !! Critical Pressures real ( wp ), dimension (:), allocatable :: dc !! Critical Densities (from EOS) real ( wp ), dimension (:), allocatable :: w !! Accentric factors ! EOS parameters real ( wp ), dimension (:), allocatable :: ac !! EOS atractive parameter real ( wp ), dimension (:), allocatable :: b !! EOS repulsive parameter real ( wp ), dimension (:), allocatable :: del1 !! EOS delta_1 real ( wp ), dimension (:), allocatable :: k !! k parameter to calculate the a parameter ! Mixing parameters real ( wp ), dimension (:, :), allocatable :: kij !! Kij matrix real ( wp ), dimension (:, :), allocatable :: kij_0 !! Kij standard real ( wp ), dimension (:, :), allocatable :: kij_inf !! Kij at infinite temperature real ( wp ), dimension (:, :), allocatable :: T_star !! Reference temperature for temperature dependent Kij real ( wp ), dimension (:, :), allocatable :: lij !! lij matrix real ( wp ), dimension (:, :), allocatable :: aij !! EOS atractive parameter matrix contains subroutine setup ( nin , filename ) !! This subroutine will be used to read data files and get the !! mixture properties integer , intent ( in ) :: nin character ( len = :), allocatable , intent ( in ) :: filename read ( nin , * ) nc read ( nin , * ) nmodel read ( nin , * ) ncomb , ntdep end subroutine setup end module mixture","tags":"","loc":"sourcefile/mixture.f90.html"},{"title":"rkpr.f90 – fedebenelli/rkpr","text":"Contents Modules rkpr Source Code rkpr.f90 Source Code module rkpr use constants implicit none contains end module rkpr","tags":"","loc":"sourcefile/rkpr.f90.html"},{"title":"mixing_rules.f90 – fedebenelli/rkpr","text":"Contents Modules mixing_rules Source Code mixing_rules.f90 Source Code module mixing_rules !! Module that contains the available mixing rules to be used. use constants implicit none contains subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic subroutine other ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! What's this?? integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j real ( wp ) :: barrgij call quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) do i = 1 , nc - 1 do j = i + 1 , nc barrgij = bij ( i , j ) / sqrt ( b ( i ) * b ( j )) aij ( i , j ) = barrgij * aij ( i , j ) aij ( j , i ) = aij ( i , j ) daijdT ( i , j ) = barrgij * daijdT ( i , j ) daijdT ( j , i ) = daijdT ( i , j ) daij2dt2 ( i , j ) = barrgij * daij2dt2 ( i , j ) daij2dt2 ( j , i ) = daij2dt2 ( i , j ) end do end do end subroutine other end module mixing_rules","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"cubic_parameter.f90 – fedebenelli/rkpr","text":"Contents Modules parameters converter Source Code cubic_parameter.f90 Source Code module parameters use iso_fortran_env implicit none real ( 8 ), save :: Tc , dc real ( 8 ), save :: a , b , del1 end module parameters module converter use iso_fortran_env use constants implicit none contains ! ============================================================================= !  Subroutines to obtain EOS parameters from critical constants ! ----------------------------------------------------------------------------- subroutine pr_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc ! Critical temperature real ( 8 ), intent ( in ) :: Pc ! Critical pressure real ( 8 ), intent ( in ) :: w ! Accentric factor real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: ac ! ac parameter real ( 8 ), intent ( out ) :: b ! Covolume real ( 8 ), intent ( out ) :: m ! Constant to calculate a(T) ! Internal varibles real ( 8 ) :: del1 = 1.0d0 + sqrt ( 2.d0 ) ! delta_1 for PR since the parameters are calculated based on the RKPR method real ( 8 ) :: OMa , OMb , Zc , Vceos ! real ( 8 ) :: RT ! R*T product RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc ! m constant to calculate a depending on temperature if ( w <= 0.491 ) then ! m from PR m = 0.37464 + 1.54226 * w - 0.26992 * w ** 2 end if if ( w > 0.491 ) then ! PR78 m = 0.379642 + 1.48503 * w - 0.164423 * w ** 2 + 0.016666 * w ** 3 end if end subroutine pr_params_from_crit subroutine srk_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: Pc real ( 8 ), intent ( out ) :: w real ( 8 ), intent ( in ) :: R real ( 8 ), intent ( out ) :: ac real ( 8 ), intent ( out ) :: b real ( 8 ), intent ( out ) :: m real ( 8 ) :: del1 = 1.0D0 real ( 8 ) :: OMa , OMb , Zc , Vceos real ( 8 ) :: RT RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc m = 0.48 + 1.574 * w - 0.175 * w ** 2 end subroutine srk_params_from_crit subroutine rkpr_params_from_crit ( & Tc , Pc , w , R , ac , b , k , del1 , Vceos , T , Pvdat , RhoLsat & ) !! Get the RKPR EOS parameters from the substance critical properties. ! Input real ( 8 ), intent ( in ) :: Tc !! Critical temperature real ( 8 ), intent ( in ) :: Pc !! Critical pressure real ( 8 ), intent ( in ) :: w !! accentric factor real ( 8 ), intent ( in ) :: R !! Gas constant ! Optional cases where extra specifications are made real ( 8 ), intent ( inout ), optional :: del1 !! delta_1 real ( 8 ), intent ( inout ), optional :: Vceos !! Critical volume at specification real ( 8 ), intent ( in ), optional :: T !! Temperature used to either estimate k or del1 real ( 8 ), intent ( inout ), optional :: Pvdat !! Vapor pressure used to estimate k real ( 8 ), intent ( in ), optional :: RhoLsat !! Saturation density used to estimate del1 !------------------------------------------------------------------------ real ( 8 ), intent ( out ) :: ac !! ac parameter real ( 8 ), intent ( out ) :: b !! covolume real ( 8 ), intent ( out ) :: k !! k to calculate \"a\" with ac and T real ( 8 ) :: OMa , OMb , Zc , RT , del1ini , dc , Tr , & a , Pv , RHOL , RHOV , phiL , delta_k , Pold , oldk , & Trho , RHOld , del1_old , delta_del1 logical :: del1_spec , Pv_spec , rhoL_spec del1_spec = . false . Pv_spec = . false . rhoL_spec = . false . if ( present ( del1 )) then del1_spec = . true . !print *, \"Specified del1\" end if if ( present ( T )) then if ( present ( Pvdat )) then Pv_spec = . true . !print *, \"Specified Pv\" end if end if if ( present ( T )) then if ( present ( RhoLsat )) then rhoL_spec = . true . !print *, \"Specified RhoLsat\" end if end if ! Initialize delta_1 and get the value that statisfies the Zc ! condition ! ----------------------------------------------------------------------- RT = R * Tc if ( present ( Vceos )) then ! Usual specification with Vceos Zc = Pc * Vceos / RT del1ini = D ( 1 ) + D ( 2 ) * ( D ( 3 ) - Zc ) ** D ( 4 ) + D ( 5 ) * ( D ( 3 ) - Zc ) ** D ( 6 ) call getdel1 ( Zc , del1ini , del1 ) end if if ( rhoL_spec ) then Trho = T / Tc del1 = 2.0 ! initial value RHOld = 0.d0 end if ! Calculate the inbetween parameters and finally get ac and b ! ----------------------------------------------------------------------- 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc ! Obtain the k parameter ! ----------------------------------------------------------------------- dc = Pc / Zc / RT Vceos = 1.0d0 / dc ! initial guess for k parameter k = ( A1 * Zc + A0 ) * w ** 2 + ( B1 * Zc + B0 ) * w + ( C1 * Zc + C0 ) a = ac * ( 3 / ( 2 + Tr )) ** k if ( del1_spec ) then Vceos = Zc * RT / Pc end if if ( Pv_spec ) then ! added 29/06/2013 in order to allow for better reproductions of Pv curves Tr = T / Tc else Tr = 0.7d0 Pvdat = Pc * 10 **- ( 1.0d0 + w ) end if ! Find the value of k that fits with the expected Pv call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) if ( Pv > Pvdat ) then delta_k = 0.1 else delta_k = - 0.1 end if do while ( abs ( Pv - Pvdat ) / Pvdat > 0.005 ) Pold = Pv oldk = k k = k + delta_k a = ac * ( 3 / ( 2 + Tr )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) delta_k = - ( Pv - Pvdat ) * ( k - oldk ) / ( Pv - Pold ) end do if ( rhoL_spec ) then ! November 2011 for RKPR specifying T, RHOLsat if ( abs ( Trho - 0.70 ) > 1.d-2 ) then ! get calculated RHOL when Trho is no 0.70 Pvdat = Pc * 10 **- (( 1. / Trho - 1 d0 ) * 7 * ( 1.0D0 + w ) / 3 ) a = ac * ( 3 / ( 2 + Trho )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Trho , Pvdat , Pv , RHOL , RHOV , phiL ) end if if ( RHOld == 0.d0 ) then del1_old = del1 ! condition for the strange case that del1=2 is solution if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) del1 = 2.1 else delta_del1 = - ( RHOL - RhoLsat ) * ( del1 - del1_old ) / ( RHOL - RHOld ) del1_old = del1 del1 = del1 + delta_del1 end if RHOld = RHOL if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) go to 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc end if end subroutine rkpr_params_from_crit ! ============================================================================= ! ========================================================================== !  Subroutines to obtain critical constants from EOS parameters ! -------------------------------------------------------------------------- subroutine pr_critical_from_params ( ac , b , m , R , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0D0 + sqrt ( 2.0 ) real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * R * b ) Pc = OMb * R * Tc / b Vceos = Zc * R * Tc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine pr_critical_from_params subroutine srk_critical_from_params ( ac , b , m , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0d0 real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = - 0.175 be = 1.574 ga = 0.48 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine srk_critical_from_params subroutine rkpr_critical_from_params ( ac , b , del1 , k , Tc , Pc , w , Vceos ) use constants real ( 8 ), intent ( in ) :: ac ! ac parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: del1 ! delta_1 parameter real ( 8 ), intent ( in ) :: k ! k parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! Accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume real ( 8 ) :: Zc , OMa , OMb , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = A1 * Zc + A0 be = B1 * Zc + B0 ga = C1 * Zc + C0 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine rkpr_critical_from_params ! ========================================================================== ! ========================================================================== !  Extra subroutines ! -------------------------------------------------------------------------- subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) real ( 8 ), intent ( in ) :: del1 ! RKPR delta_1 parameter real ( 8 ), intent ( out ) :: Zc ! Critical compressibility factor real ( 8 ), intent ( out ) :: OMa ! real ( 8 ), intent ( out ) :: OMb ! real ( 8 ) :: d1 , y d1 = ( 1.d0 + del1 ** 2.d0 ) / ( 1.d0 + del1 ) y = 1.d0 + ( 2.d0 * ( 1.d0 + del1 )) ** ( 1.0d0 / 3.d0 ) + ( 4.d0 / ( 1.d0 + del1 )) ** ( 1.0d0 / 3 ) OMa = ( 3.d0 * y * y + 3.d0 * y * d1 + d1 ** 2.d0 + d1 - 1.0d0 ) / ( 3.d0 * y + d1 - 1.0d0 ) ** 2.d0 OMb = 1.d0 / ( 3.d0 * y + d1 - 1.0d0 ) Zc = y / ( 3.d0 * y + d1 - 1.0d0 ) end subroutine get_Zc_OMa_OMb subroutine getdel1 ( Zc_in , del1_ini , del1 ) real ( 8 ), intent ( in ) :: Zc_in real ( 8 ), intent ( in ) :: del1_ini real ( 8 ), intent ( out ) :: del1 real ( 8 ) :: d1 , y , del1_old , Zc , Z_old , aux , error = 1.d0 del1 = del1_ini d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Zc = y / ( 3 * y + d1 - 1.0d0 ) del1_old = del1 if ( Zc . gt . Zc_in ) then del1 = 1.01 * del1 else del1 = 0.99 * del1 end if do while ( error >= 1.0d-6 ) d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Z_old = Zc Zc = y / ( 3 * y + d1 - 1.0d0 ) aux = del1 del1 = del1 - ( Zc - Zc_in ) * ( del1 - del1_old ) / ( Zc - Z_old ) del1_old = aux error = abs ( Zc - Zc_in ) end do end subroutine getdel1 recursive subroutine VaporPressure ( & a , b , del1 , Tc , dc , Tr , PVini , Pv , RHOL , RHOV , phiL & ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: dc real ( 8 ), intent ( in ) :: Tr real ( 8 ), intent ( in ) :: PVini real ( 8 ), intent ( out ) :: Pv real ( 8 ), intent ( out ) :: RHOL real ( 8 ), intent ( out ) :: RHOV real ( 8 ), intent ( out ) :: phiL real ( 8 ) :: dphi = 0.d0 , P , T , V , phi , phiV , dphiold , Pold , Plast P = PVini T = Tr * Tc do while ( RHOL < 0.9 * dc . or . RHOV > dc ) if ( RHOL < 0.9 * dc ) then P = 1.01 * P else if ( RHOV > dc ) then P = 0.99 * P end if call VCALC ( 1 , a , b , del1 , T , P , V ) RHOL = 1 / V call VCALC ( - 1 , a , b , del1 , T , P , V ) ! SOLVE for vapor density RHOV = 1 / V end do call FUG_CALC ( a , b , del1 , T , P , 1 / RHOL , phi ) phiL = phi call FUG_CALC ( a , b , del1 , T , P , V , phi ) phiV = phi dphiold = dphi dphi = phiV - phiL ! ASK: Is this really a recursion? Plast = P if ( ABS ( dphi ) . gt . ERRMAX ) then Pold = Plast Plast = P if ( dphiold == 0.0D0 . or . Tr . gt . 0.975 ) then P = P * ( phiL / phiV ) else P = Plast - dphi * ( Plast - Pold ) / ( dphi - dphiold ) end if call VaporPressure ( a , b , del1 , Tc , dc , Tr , P , Pv , RHOL , RHOV , phiL ) end if PV = P return end recursive subroutine VCALC ( ITYP , a , b , del1 , T , P , V ) ! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use constants , only : RGAS integer , intent ( in ) :: ITYP ! Type of root desired 1 for liquid -1 for vapor real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( out ) :: V ! Internal variables integer :: ITER logical :: FIRST_RUN real ( 8 ) :: ZETMIN , ZETMAX , ZETA , F , F_V , F_2V , F_N , & PCALC , del , AT , DER , VVAP , AVAP FIRST_RUN = . TRUE . ITER = 0 ZETMIN = 0.D0 ZETMAX = . 99 D0 if ( ITYP . GT . 0 ) then ! Liquid estimate ZETA = . 5 D0 else ! Ideal gas estimate ZETA = MIN (. 5 D0 , b * P / ( RGAS * T )) end if del = 1.d0 do while ( abs ( del ) > 1 d - 10 ) V = b / ZETA ITER = ITER + 1 CALL vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) PCALC = RGAS * T * ( 1 / V - F_V ) if ( PCALC . GT . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = F - LOG ( V ) + V * P / ( T * RGAS ) DER = RGAS * T * ( F_2V + 1.d0 ) / b DEL = - ( PCALC - P ) / DER ZETA = ZETA + MAX ( MIN ( DEL , 0.1d0 ), - 0.1d0 ) if ( ZETA . GT . ZETMAX . OR . ZETA . LT . ZETMIN ) then ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end if end do if ( ITYP == 0 ) then VVAP = V AVAP = AT ! Calculate Liquid volume and It's energy call VCALC ( 1 , a , b , del1 , T , P , V ) call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) AT = F - LOG ( V ) + V * P / ( T * RGAS ) if ( AT . GT . AVAP ) V = VVAP end if end subroutine VCALC subroutine vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) ! CALCULATES THE CONTRIBUTION TO THE RESIDUAL, REDUCED HELMHOLZ ENERGY (F) ! AND ITS FIRST AND SECOND DERIVATIVE WRT V use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T ! Temperature [K] real ( 8 ), intent ( in ) :: V ! Volume: [mL/mol] or [mL] for checking n-derivatives real ( 8 ), intent ( out ) :: F ! A&#94;RES/RT CONTRIBUTION (DIMENSIONLESS) or (MOLES) real ( 8 ), intent ( out ) :: F_V ! 1ST V-DERIVATIVE OF F real ( 8 ), intent ( out ) :: F_2V ! 1ST V-DERIVATIVE OF F_V  (*V**2) real ( 8 ), intent ( out ) :: F_N ! 1ST N-DERIVATIVE OF F real ( 8 ) :: C , aRT , ETA , SUMC , SUMD , REP , ATT , ATTV , REPV , REP2V , ATT2V C = ( 1 - del1 ) / ( 1 + del1 ) aRT = a / ( RGAS * T ) ETA = 0.25 * b / V SUMC = c * b + V SUMD = del1 * b + V REP = - log ( 1 - 4 * ETA ) ATT = aRT * LOG ( SUMD / SUMC ) / ( b * ( C - del1 )) ATTV = aRT / SUMC / SUMD REPV = 1 / ( 1 - 4 * ETA ) - 1 REP2V = 1 / ( 1 - 4 * ETA ) ** 2 - 1 ATT2V = aRT * V ** 2 * ( 1 / SUMD ** 2 - 1 / SUMC ** 2 ) / ( b * ( C - del1 )) F = REP + ATT F_V = ( - REPV / V + ATTV ) F_2V = REP2V - ATT2V F_N = REP + ATT - V * F_V end subroutine FUG_CALC ( a , b , del1 , T , P , V , phi ) use constants real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( in ) :: V real ( 8 ), intent ( out ) :: phi real ( 8 ) :: RT , Z , F , F_V , F_2V , F_N RT = RGAS * T Z = P * V / RT call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) phi = exp ( F_N ) / Z end ! ========================================================================== end module converter","tags":"","loc":"sourcefile/cubic_parameter.f90.html"},{"title":"main.f90 – fedebenelli/rkpr","text":"Contents Programs main Source Code main.f90 Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"compound – fedebenelli/rkpr ","text":"type, public :: compound Contents Variables ac b k pc tc w Source Code compound Components Type Visibility Attributes Name Initial real(kind=wp), public :: ac real(kind=wp), public :: b real(kind=wp), public :: k real(kind=wp), public :: pc real(kind=wp), public :: tc real(kind=wp), public :: w Source Code type compound !! real ( wp ) :: tc real ( wp ) :: pc real ( wp ) :: ac real ( wp ) :: b real ( wp ) :: w real ( wp ) :: k end type compound","tags":"","loc":"type/compound.html"},{"title":"mix – fedebenelli/rkpr ","text":"type, public :: mix Contents Variables T_star ac aij b dc del1 k kij kij0 kij_inf lij n names nc ncomb nmodel ntdep pc tc w Source Code mix Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:), allocatable :: n Number of moles character(len=:), public, dimension(:), allocatable :: names Components names integer, public :: nc Number of components integer, public :: ncomb Combining rule integer, public :: nmodel Model to use integer, public :: ntdep Temperature dependence real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: w Accentric factors Source Code type mix integer :: nmodel !! Model to use integer :: nc !! Number of components integer :: ntdep !! Temperature dependence integer :: ncomb !! Combining rule character ( len = :), dimension (:), allocatable :: names !! Components names real ( wp ), dimension (:), allocatable :: n !! Number of moles ! Properties real ( wp ), dimension (:), allocatable :: tc !! Critical Temperatures real ( wp ), dimension (:), allocatable :: pc !! Critical Pressures real ( wp ), dimension (:), allocatable :: dc !! Critical Densities (from EOS) real ( wp ), dimension (:), allocatable :: w !! Accentric factors ! EOS parameters real ( wp ), dimension (:), allocatable :: ac !! EOS atractive parameter real ( wp ), dimension (:), allocatable :: b !! EOS repulsive parameter real ( wp ), dimension (:), allocatable :: del1 !! EOS delta_1 real ( wp ), dimension (:), allocatable :: k !! k parameter to calculate the a parameter ! Mixing parameters real ( wp ), dimension (:, :), allocatable :: kij !! Kij matrix real ( wp ), dimension (:, :), allocatable :: kij0 !! Kij standard real ( wp ), dimension (:, :), allocatable :: kij_inf !! Kij at infinite temperature real ( wp ), dimension (:, :), allocatable :: T_star !! Reference temperature for temperature dependent Kij real ( wp ), dimension (:, :), allocatable :: lij !! lij matrix real ( wp ), dimension (:, :), allocatable :: aij !! EOS atractive parameter matrix end type mix","tags":"","loc":"type/mix.html"},{"title":"Bmixnder – fedebenelli/rkpr","text":"public subroutine Bmixnder(nc, n, bij, B_mix, dBdni, dB2dnij2) Repulsive parameter of the mixture and it’s compositional derivatives. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=wp), intent(in) :: n (nc) real(kind=wp), intent(in) :: bij (nc,nc) real(kind=wp), intent(out) :: B_mix real(kind=wp), intent(out) :: dBdni (nc) real(kind=wp), intent(out) :: dB2dnij2 (nc,nc) Contents Variables aux i j totn Variables Type Visibility Attributes Name Initial real(kind=wp), public :: aux (nc) integer, public :: i integer, public :: j real(kind=wp), public :: totn","tags":"","loc":"proc/bmixnder.html"},{"title":"aTder – fedebenelli/rkpr","text":"public subroutine aTder(T, a, dadT, dadT2) Uses mixture Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: a (nc) Atractive parameter at T real(kind=wp), intent(out) :: dadT (nc) First deritvative with T real(kind=wp), intent(out) :: dadT2 (nc) Second derivative with T Contents Variables Tr Source Code aTder Variables Type Visibility Attributes Name Initial real(kind=wp), public :: Tr (nc) Source Code subroutine aTder ( T , a , dadT , dadT2 ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. use mixture , only : nmodel , ac , k , tc , nc real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: a ( nc ) !! Atractive parameter at T real ( wp ), intent ( out ) :: dadT ( nc ) !! First deritvative with T real ( wp ), intent ( out ) :: dadT2 ( nc ) !! Second derivative with T real ( wp ) :: Tr ( nc ) ! Reduced temperature Tr = T / Tc if ( nmodel <= 2 ) then ! SRK and PR a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc dadT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) else if ( nmodel == 3 ) then ! RKPR EOS a = ac * ( 3 / ( 2 + Tr )) ** k dadT = - k * a / Tc / ( 2 + Tr ) dadT2 = - ( k + 1 ) * dadT / Tc / ( 2 + Tr ) end if end subroutine aTder","tags":"","loc":"proc/atder.html"},{"title":"aijTder – fedebenelli/rkpr","text":"public subroutine aijTder(T, aij, daijdT, daij2dT2) Uses mixing_rules mixture Calculate the binary atractive term matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: aij (nc,nc) Atractive binary terms matrix real(kind=wp), intent(out) :: daijdT (nc,nc) Atractive binary terms matrix first derivative with temperature real(kind=wp), intent(out) :: daij2dT2 (nc,nc) Atractive binary terms matrix second derivative with temperature Contents Variables a b bij da2dT2 dadT dkij2dt2 dkijdt Source Code aijTder Variables Type Visibility Attributes Name Initial real(kind=wp), public :: a (nc) real(kind=wp), public :: b (nc) real(kind=wp), public :: bij (nc,nc) real(kind=wp), public :: da2dT2 (nc) real(kind=wp), public :: dadT (nc) real(kind=wp), public :: dkij2dt2 (nc,nc) real(kind=wp), public :: dkijdt (nc,nc) Source Code subroutine aijTder ( T , aij , daijdT , daij2dT2 ) !! Calculate the binary atractive term matrix use mixture , only : nc , ntdep , kij , kij_0 , lij , ncomb use mixing_rules , only : quadratic implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Atractive binary terms matrix real ( wp ), intent ( out ) :: daijdT ( nc , nc ) !! Atractive binary terms matrix first derivative with temperature real ( wp ), intent ( out ) :: daij2dT2 ( nc , nc ) !! Atractive binary terms matrix second derivative with temperature real ( wp ) :: dkijdt ( nc , nc ), dkij2dt2 ( nc , nc ) ! kij T derivatives real ( wp ) :: a ( nc ), dadT ( nc ), da2dT2 ( nc ) ! Atractive parameter and T derivatives real ( wp ) :: b ( nc ), bij ( nc , nc ) ! Repulsive parameter (just to use as input in subroutine) b = 0 ! Here only the aij for the mixture, so there is no need to use the real b select case ( ntdep ) case ( 1 ) ! Kij exponential temperature dependance call kij_tdep ( T , kij , dkijdt , dkij2dt2 ) case default kij = kij_0 dkijdt = 0 dkij2dt2 = 0 end select ! Calculate pure compound atractive parameters at T call aTder ( T , a , dadT , da2dT2 ) ! Apply combining rule select case ( ncomb ) case default call quadtratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , & lij , aij , daijdt , daij2dt2 , bij ) end select end subroutine aijTder","tags":"","loc":"proc/aijtder.html"},{"title":"amixTnder – fedebenelli/rkpr","text":"public subroutine amixTnder(nc, T, n, a, dadni, da2dniT2, da2dnij2, dadT, da2dT2) Atractive parameter of a mixture and it’s derivatives Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(in) :: n (nc) Matrix with number of moles real(kind=wp), intent(out) :: a Mixture atractive parameter real(kind=wp), intent(out) :: dadni (nc) Atractive parameter first derivative with number of moles real(kind=wp), intent(out) :: da2dniT2 (nc) Atractive parameter second derivative with moles and Tempeature real(kind=wp), intent(out) :: da2dnij2 (nc,nc) Atractive parameter second derivative with number of moles real(kind=wp), intent(out) :: dadT (nc) Atractive parameter first derivative with Tempeature real(kind=wp), intent(out) :: da2dT2 (nc) Atractive parameter first derivative with Tempeature Contents Variables aij aux aux2 daijdT daijdT2 i j Source Code amixTnder Variables Type Visibility Attributes Name Initial real(kind=wp), public :: aij (nc,nc) real(kind=wp), public :: aux real(kind=wp), public :: aux2 real(kind=wp), public :: daijdT (nc,nc) real(kind=wp), public :: daijdT2 (nc,nc) integer, public :: i integer, public :: j Source Code subroutine amixTnder ( nc , T , n , a , dadni , da2dniT2 , da2dnij2 , dadT , da2dT2 ) !! Atractive parameter of a mixture and it's derivatives integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( in ) :: n ( nc ) !! Matrix with number of moles real ( wp ), intent ( out ) :: a !! Mixture atractive parameter real ( wp ), intent ( out ) :: dadni ( nc ) !! Atractive parameter first derivative with number of moles real ( wp ), intent ( out ) :: da2dniT2 ( nc ) !! Atractive parameter second derivative with moles and Tempeature real ( wp ), intent ( out ) :: da2dnij2 ( nc , nc ) !! Atractive parameter second derivative with number of moles real ( wp ), intent ( out ) :: dadT ( nc ) !! Atractive parameter first derivative with Tempeature real ( wp ), intent ( out ) :: da2dT2 ( nc ) !! Atractive parameter first derivative with Tempeature real ( wp ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( wp ) :: aux , aux2 integer :: i , j ! TODO: An already calculated aij matrix could be the input call aijTder ( T , aij , daijdT , daijdT2 ) a = 0.0_wp dadT = 0.0_wp da2dT2 = 0.0_wp do i = 1 , nc aux = 0.0_wp aux2 = 0.0_wp dadni ( i ) = 0.0_wp da2dniT2 ( i ) = 0.0_wp do j = 1 , nc dadni ( i ) = dadni ( i ) + 2 * n ( j ) * aij ( i , j ) da2dniT2 ( i ) = da2dniT2 ( i ) + 2 * n ( j ) * daijdT ( i , j ) da2dnij2 ( i , j ) = 2 * aij ( i , j ) aux = aux + n ( j ) * aij ( i , j ) aux2 = aux2 + n ( j ) * daijdT2 ( i , j ) end do a = a + n ( i ) * aux dadT = dadT + n ( i ) * da2dniT2 ( i ) / 2 da2dT2 = da2dT2 + n ( i ) * aux2 end do end subroutine amixTnder","tags":"","loc":"proc/amixtnder.html"},{"title":"d1nder – fedebenelli/rkpr","text":"public subroutine d1nder(nc, n, d1, d1_mix, dD1dni, dD12dnij2) Delta_1 of the mixture and compositional derivatives. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components. real(kind=wp), intent(in) :: n (nc) Array of mole numbers for each component. real(kind=wp), intent(in) :: d1 (nc) Array of delta 1 parameters for each component. real(kind=wp), intent(out) :: d1_mix ?? real(kind=wp), intent(out) :: dD1dni (nc) delta1 parameter first derivative with composition. real(kind=wp), intent(out) :: dD12dnij2 (nc,nc) delta1 parameter second derivative with composition. Contents Variables i j totn Source Code d1nder Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: totn Source Code subroutine d1nder ( nc , n , d1 , d1_mix , dD1dni , dD12dnij2 ) !! Delta_1 of the mixture and compositional derivatives. integer , intent ( in ) :: nc !! Number of components. real ( wp ), intent ( in ) :: n ( nc ) !! Array of mole numbers for each component. real ( wp ), intent ( in ) :: d1 ( nc ) !! Array of delta 1 parameters for each component. real ( wp ), intent ( out ) :: d1_mix !! ?? real ( wp ), intent ( out ) :: dD1dni ( nc ) !! delta1 parameter first derivative with composition. real ( wp ), intent ( out ) :: dD12dnij2 ( nc , nc ) !! delta1 parameter second derivative with composition. integer :: i , j real ( wp ) :: totn ! Total number of moles d1_mix = 0.0_wp do i = 1 , nc d1_mix = d1_mix + n ( i ) * d1 ( i ) end do totn = sum ( n ) d1_mix = d1_mix / totn do i = 1 , nc dD1dni ( i ) = ( d1 ( i ) - d1_mix ) / totn do j = 1 , nc dD12dnij2 ( i , j ) = ( 2.0_wp * d1_mix - d1 ( i ) - d1 ( j )) / totn ** 2 end do end do end subroutine d1nder","tags":"","loc":"proc/d1nder.html"},{"title":"helmholtz_energy – fedebenelli/rkpr","text":"public subroutine helmholtz_energy(nc, ND, NT, n, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: ND integer, intent(in) :: NT real(kind=wp), intent(in) :: n (nc) Number of moles real(kind=wp), intent(in) :: V real(kind=wp), intent(in) :: T real(kind=wp), intent(out) :: Ar real(kind=wp), intent(out) :: ArV real(kind=wp), intent(out) :: ArTV real(kind=wp), intent(out) :: ArV2 real(kind=wp), intent(out) :: Arn (nc) real(kind=wp), intent(out) :: ArVn (nc) real(kind=wp), intent(out) :: ArTn (nc) real(kind=wp), intent(out) :: Arn2 (nc,nc) Contents Variables Kij ac aij b dBi dBij dDi dDiT dDij daijdT daijdT2 del1 rm Source Code helmholtz_energy Variables Type Visibility Attributes Name Initial real(kind=wp), public :: Kij (nco,nco) real(kind=wp), public :: ac (nco) real(kind=wp), public :: aij (nc,nc) real(kind=wp), public :: b (nco) real(kind=wp), public :: dBi (nc) real(kind=wp), public :: dBij (nc,nc) real(kind=wp), public :: dDi (nc) real(kind=wp), public :: dDiT (nc) real(kind=wp), public :: dDij (nc,nc) real(kind=wp), public :: daijdT (nc,nc) real(kind=wp), public :: daijdT2 (nc,nc) real(kind=wp), public :: del1 (nco) real(kind=wp), public :: rm (nco) Source Code subroutine helmholtz_energy ( nc , ND , NT , n , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) integer , intent ( in ) :: nc !! Number of components integer , intent ( in ) :: ND , NT real ( wp ), intent ( in ) :: n ( nc ) !! Number of moles real ( wp ), intent ( in ) :: V !! real ( wp ), intent ( in ) :: T real ( wp ), intent ( out ) :: Ar real ( wp ), intent ( out ) :: ArV real ( wp ), intent ( out ) :: ArTV real ( wp ), intent ( out ) :: ArV2 real ( wp ), intent ( out ) :: Arn ( nc ) real ( wp ), intent ( out ) :: ArVn ( nc ) real ( wp ), intent ( out ) :: ArTn ( nc ) real ( wp ), intent ( out ) :: Arn2 ( nc , nc ) real ( wp ) :: dBi ( nc ), dBij ( nc , nc ) real ( wp ) :: dDi ( nc ), dDij ( nc , nc ), dDiT ( nc ) real ( wp ) :: aij ( nc , nc ), daijdT ( nc , nc ), daijdT2 ( nc , nc ) real ( wp ) :: Kij ( nco , nco ) real ( wp ) :: ac ( nco ), b ( nco ), del1 ( nco ), rm ( nco ) TOTN = sum ( rn ) D1 = del1 ( 1 ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( ncomb . lt . 2 ) then call amixTnder ( nc , T , n , a , dadni , da2dniT2 , da2dnij2 , dadT , da2dT2 ) call Bmixnder ( nc , rn , Bmix , dBi , dBij ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NT,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if ! The f's and g's used here are for Ar, not F (reduced Ar) ! This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = RGAS * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) gv = RGAS * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = RGAS * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) fB = - ( f + V * fv ) / Bmix ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = RGAS * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) if ( ND . EQ . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES IF ( NT . EQ . 1 ) THEN ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) end do END IF end subroutine helmholtz_energy","tags":"","loc":"proc/helmholtz_energy.html"},{"title":"helmholtz_energy_RKPR – fedebenelli/rkpr","text":"public subroutine helmholtz_energy_RKPR(nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer :: nco integer :: NDE integer :: NTD real :: rn real :: V real :: T real :: Ar real :: ArV real :: ArTV real :: ArV2 real :: Arn real :: ArVn real :: ArTn real :: Arn2 Contents Common Blocks rule Source Code helmholtz_energy_RKPR Common Blocks common /rule/ Type Attributes Name Initial integer :: ncomb Combining rule Source Code subroutine helmholtz_energy_RKPR ( nco , NDE , NTD , rn , V , T , Ar , ArV , ArTV , ArV2 , Arn , ArVn , ArTn , Arn2 ) !! Calculate the reduced residual Helmholtz Energy and it's derivatives with the RKPR EOS IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) PARAMETER ( RGAS = 0.08314472d0 ) dimension :: rn ( nco ), Arn ( nco ), ArVn ( nco ), ArTn ( nco ), Arn2 ( nco , nco ) dimension dBi ( nco ), dBij ( nco , nco ), dD1i ( nco ), dD1ij ( nco , nco ) dimension dDi ( nco ), dDij ( nco , nco ), dDiT ( nco ) dimension aij ( nco , nco ), daijdT ( nco , nco ), daijdT2 ( nco , nco ) COMMON / rule / ncomb nc = nco TOTN = sum ( rn ) call DELTAnder ( nc , rn , D1 , dD1i , dD1ij ) D2 = ( 1 - D1 ) / ( 1 + D1 ) if ( ncomb . lt . 2 ) then call Bnder ( nc , rn , Bmix , dBi , dBij ) call DandTnder ( NTD , nc , T , rn , D , dDi , dDiT , dDij , dDdT , dDdT2 ) else ! call Bcubicnder(nc,rn,Bmix,dBi,dBij) ! call DCubicandTnder(NTD,nc,T,rn,D,dDi,dDiT,dDij,dDdT,dDdT2) end if !  The f's and g's used here are for Ar, not F (reduced Ar) !  This requires to multiply by R all g, f and its derivatives as defined by Mollerup f = log (( V + D1 * Bmix ) / ( V + D2 * Bmix )) / Bmix / ( D1 - D2 ) g = RGAS * log ( 1 - Bmix / V ) fv = - 1 / (( V + D1 * Bmix ) * ( V + D2 * Bmix )) fB = - ( f + V * fv ) / Bmix gv = RGAS * Bmix / ( V * ( V - Bmix )) fv2 = ( - 1 / ( V + D1 * Bmix ) ** 2 + 1 / ( V + D2 * Bmix ) ** 2 ) / Bmix / ( D1 - D2 ) gv2 = RGAS * ( 1 / V ** 2 - 1 / ( V - Bmix ) ** 2 ) ! DERIVATIVES OF f WITH RESPECT TO DELTA1 auxD2 = ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1 = ( 1 / ( V + D1 * Bmix ) + 2 / ( V + D2 * Bmix ) / ( 1 + D1 ) ** 2 ) - f * auxD2 fD1 = fD1 / ( D1 - D2 ) fBD1 = - ( fB * auxD2 + D1 / ( V + D1 * Bmix ) ** 2 + 2 * D2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) fBD1 = fBD1 / ( D1 - D2 ) fVD1 = - ( fV * auxD2 + 1 / ( V + D1 * Bmix ) ** 2 + 2 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 2 ) / ( D1 - D2 ) fD1D1 = 4 * ( f - 1 / ( V + D2 * Bmix )) / ( 1 + D1 ) ** 3 + Bmix * ( - 1 / ( V + D1 * Bmix ) ** 2 & + 4 / ( V + D2 * Bmix ) ** 2 / ( 1 + D1 ) ** 4 ) - 2 * fD1 * ( 1 + 2 / ( 1 + D1 ) ** 2 ) fD1D1 = fD1D1 / ( D1 - D2 ) ! Reduced Helmholtz Energy and derivatives Ar = - TOTN * g * T - D * f ArV = - TOTN * gv * T - D * fv ArV2 = - TOTN * gv2 * T - D * fv2 AUX = RGAS * T / ( V - Bmix ) FFB = TOTN * AUX - D * fB FFBV = - TOTN * AUX / ( V - Bmix ) + D * ( 2 * fv + V * fv2 ) / Bmix FFBB = TOTN * AUX / ( V - Bmix ) - D * ( 2 * f + 4 * V * fv + V ** 2 * fv2 ) / Bmix ** 2 do i = 1 , nc Arn ( i ) = - g * T + FFB * dBi ( i ) - f * dDi ( i ) - D * fD1 * dD1i ( i ) ArVn ( i ) = - gv * T + FFBV * dBi ( i ) - fv * dDi ( i ) - D * fVD1 * dD1i ( i ) if ( NDE . EQ . 2 ) then do j = 1 , i Arn2 ( i , j ) = AUX * ( dBi ( i ) + dBi ( j )) - fB * ( dBi ( i ) * dDi ( j ) + dBi ( j ) * dDi ( i )) & + FFB * dBij ( i , j ) + FFBB * dBi ( i ) * dBi ( j ) - f * dDij ( i , j ) Arn2 ( i , j ) = Arn2 ( i , j ) - D * fBD1 * ( dBi ( i ) * dD1i ( j ) + dBi ( j ) * dD1i ( i )) & - fD1 * ( dDi ( i ) * dD1i ( j ) + dDi ( j ) * dD1i ( i )) & - D * fD1 * dD1ij ( i , j ) - D * fD1D1 * dD1i ( i ) * dD1i ( j ) Arn2 ( j , i ) = Arn2 ( i , j ) end do end if end do ! TEMPERATURE DERIVATIVES IF ( NTD . EQ . 1 ) THEN ArT = - TOTN * g - dDdT * f ArTV = - TOTN * gv - dDdT * fV ArTT = - dDdT2 * f do i = 1 , nc ArTn ( i ) = - g + ( TOTN * AUX / T - dDdT * fB ) * dBi ( i ) - f * dDiT ( i ) - dDdT * fD1 * dD1i ( i ) end do END IF end subroutine helmholtz_energy_RKPR","tags":"","loc":"proc/helmholtz_energy_rkpr.html"},{"title":"kij_tdep – fedebenelli/rkpr","text":"public subroutine kij_tdep(T, kij, dkijdt, dkij2dt2) Uses mixture Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: kij (nc,nc) Binary interaction parameter matrix real(kind=wp), intent(out) :: dkijdt (nc,nc) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out) :: dkij2dt2 (nc,nc) Binary interaction parameter second derivative with T matrix Contents Variables i Source Code kij_tdep Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine kij_tdep ( T , kij , dkijdt , dkij2dt2 ) !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module use mixture , only : nc , kij_0 , kij_inf , T_star implicit none real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), intent ( out ) :: kij ( nc , nc ) !! Binary interaction parameter matrix real ( wp ), intent ( out ) :: dkijdt ( nc , nc ) !! Binary interaction parameter first derivative with T matrix real ( wp ), intent ( out ) :: dkij2dt2 ( nc , nc ) !! Binary interaction parameter second derivative with T matrix integer :: i do i = 1 , nc kij (: i - 1 , i ) = kij_inf (: i - 1 , i ) + kij_0 (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkijdt (: i - 1 , i ) = - kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) * exp ( - T / T_star (: i - 1 , i )) dkij2dt2 (: i - 1 , i ) = kij_0 (: i - 1 , i ) / T_star (: i - 1 , i ) ** 2 * exp ( - T / T_star (: i - 1 , i )) end do end subroutine kij_tdep","tags":"","loc":"proc/kij_tdep.html"},{"title":"setup – fedebenelli/rkpr","text":"public subroutine setup(nin, filename) This subroutine will be used to read data files and get the\nmixture properties Arguments Type Intent Optional Attributes Name integer, intent(in) :: nin character(len=:), intent(in), allocatable :: filename Contents Source Code setup Source Code subroutine setup ( nin , filename ) !! This subroutine will be used to read data files and get the !! mixture properties integer , intent ( in ) :: nin character ( len = :), allocatable , intent ( in ) :: filename read ( nin , * ) nc read ( nin , * ) nmodel read ( nin , * ) ncomb , ntdep end subroutine setup","tags":"","loc":"proc/setup.html"},{"title":"other – fedebenelli/rkpr","text":"public subroutine other(nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) What’s this?? Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix Contents Variables barrgij i j Source Code other Variables Type Visibility Attributes Name Initial real(kind=wp), public :: barrgij integer, public :: i integer, public :: j Source Code subroutine other ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! What's this?? integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j real ( wp ) :: barrgij call quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) do i = 1 , nc - 1 do j = i + 1 , nc barrgij = bij ( i , j ) / sqrt ( b ( i ) * b ( j )) aij ( i , j ) = barrgij * aij ( i , j ) aij ( j , i ) = aij ( i , j ) daijdT ( i , j ) = barrgij * daijdT ( i , j ) daijdT ( j , i ) = daijdT ( i , j ) daij2dt2 ( i , j ) = barrgij * daij2dt2 ( i , j ) daij2dt2 ( j , i ) = daij2dt2 ( i , j ) end do end do end subroutine other","tags":"","loc":"proc/other.html"},{"title":"quadratic – fedebenelli/rkpr","text":"public subroutine quadratic(nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix Contents Variables i j Source Code quadratic Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j Source Code subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic","tags":"","loc":"proc/quadratic.html"},{"title":"FUG_CALC – fedebenelli/rkpr","text":"public subroutine FUG_CALC(a, b, del1, T, P, V, phi) Uses constants Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi Contents Variables F F_2V F_N F_V RT Z Variables Type Visibility Attributes Name Initial real(kind=8), public :: F real(kind=8), public :: F_2V real(kind=8), public :: F_N real(kind=8), public :: F_V real(kind=8), public :: RT real(kind=8), public :: Z","tags":"","loc":"proc/fug_calc.html"},{"title":"VCALC – fedebenelli/rkpr","text":"public recursive subroutine VCALC(ITYP, a, b, del1, T, P, V) Uses constants Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V Contents Variables AT AVAP DER F FIRST_RUN F_2V F_N F_V ITER PCALC VVAP ZETA ZETMAX ZETMIN del Source Code VCALC Variables Type Visibility Attributes Name Initial real(kind=8), public :: AT real(kind=8), public :: AVAP real(kind=8), public :: DER real(kind=8), public :: F logical, public :: FIRST_RUN real(kind=8), public :: F_2V real(kind=8), public :: F_N real(kind=8), public :: F_V integer, public :: ITER real(kind=8), public :: PCALC real(kind=8), public :: VVAP real(kind=8), public :: ZETA real(kind=8), public :: ZETMAX real(kind=8), public :: ZETMIN real(kind=8), public :: del Source Code recursive subroutine VCALC ( ITYP , a , b , del1 , T , P , V ) ! ROUTINE FOR CALCULATION OF VOLUME, GIVEN PRESSURE use constants , only : RGAS integer , intent ( in ) :: ITYP ! Type of root desired 1 for liquid -1 for vapor real ( 8 ), intent ( in ) :: a real ( 8 ), intent ( in ) :: b real ( 8 ), intent ( in ) :: del1 real ( 8 ), intent ( in ) :: T real ( 8 ), intent ( in ) :: P real ( 8 ), intent ( out ) :: V ! Internal variables integer :: ITER logical :: FIRST_RUN real ( 8 ) :: ZETMIN , ZETMAX , ZETA , F , F_V , F_2V , F_N , & PCALC , del , AT , DER , VVAP , AVAP FIRST_RUN = . TRUE . ITER = 0 ZETMIN = 0.D0 ZETMAX = . 99 D0 if ( ITYP . GT . 0 ) then ! Liquid estimate ZETA = . 5 D0 else ! Ideal gas estimate ZETA = MIN (. 5 D0 , b * P / ( RGAS * T )) end if del = 1.d0 do while ( abs ( del ) > 1 d - 10 ) V = b / ZETA ITER = ITER + 1 CALL vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) PCALC = RGAS * T * ( 1 / V - F_V ) if ( PCALC . GT . P ) then ZETMAX = ZETA else ZETMIN = ZETA end if AT = F - LOG ( V ) + V * P / ( T * RGAS ) DER = RGAS * T * ( F_2V + 1.d0 ) / b DEL = - ( PCALC - P ) / DER ZETA = ZETA + MAX ( MIN ( DEL , 0.1d0 ), - 0.1d0 ) if ( ZETA . GT . ZETMAX . OR . ZETA . LT . ZETMIN ) then ZETA = . 5 D0 * ( ZETMAX + ZETMIN ) end if end do if ( ITYP == 0 ) then VVAP = V AVAP = AT ! Calculate Liquid volume and It's energy call VCALC ( 1 , a , b , del1 , T , P , V ) call vdWg_Derivs ( a , b , del1 , T , V , F , F_V , F_2V , F_N ) AT = F - LOG ( V ) + V * P / ( T * RGAS ) if ( AT . GT . AVAP ) V = VVAP end if end subroutine VCALC","tags":"","loc":"proc/vcalc.html"},{"title":"VaporPressure – fedebenelli/rkpr","text":"public recursive subroutine VaporPressure(a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Uses constants Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL Contents Variables P Plast Pold T V dphi dphiold phi phiV Variables Type Visibility Attributes Name Initial real(kind=8), public :: P real(kind=8), public :: Plast real(kind=8), public :: Pold real(kind=8), public :: T real(kind=8), public :: V real(kind=8), public :: dphi = 0.d0 real(kind=8), public :: dphiold real(kind=8), public :: phi real(kind=8), public :: phiV","tags":"","loc":"proc/vaporpressure.html"},{"title":"get_Zc_OMa_OMb – fedebenelli/rkpr","text":"public subroutine get_Zc_OMa_OMb(del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb Contents Variables d1 y Source Code get_Zc_OMa_OMb Variables Type Visibility Attributes Name Initial real(kind=8), public :: d1 real(kind=8), public :: y Source Code subroutine get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) real ( 8 ), intent ( in ) :: del1 ! RKPR delta_1 parameter real ( 8 ), intent ( out ) :: Zc ! Critical compressibility factor real ( 8 ), intent ( out ) :: OMa ! real ( 8 ), intent ( out ) :: OMb ! real ( 8 ) :: d1 , y d1 = ( 1.d0 + del1 ** 2.d0 ) / ( 1.d0 + del1 ) y = 1.d0 + ( 2.d0 * ( 1.d0 + del1 )) ** ( 1.0d0 / 3.d0 ) + ( 4.d0 / ( 1.d0 + del1 )) ** ( 1.0d0 / 3 ) OMa = ( 3.d0 * y * y + 3.d0 * y * d1 + d1 ** 2.d0 + d1 - 1.0d0 ) / ( 3.d0 * y + d1 - 1.0d0 ) ** 2.d0 OMb = 1.d0 / ( 3.d0 * y + d1 - 1.0d0 ) Zc = y / ( 3.d0 * y + d1 - 1.0d0 ) end subroutine get_Zc_OMa_OMb","tags":"","loc":"proc/get_zc_oma_omb.html"},{"title":"getdel1 – fedebenelli/rkpr","text":"public subroutine getdel1(Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 Contents Variables Z_old Zc aux d1 del1_old error y Source Code getdel1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: Z_old real(kind=8), public :: Zc real(kind=8), public :: aux real(kind=8), public :: d1 real(kind=8), public :: del1_old real(kind=8), public :: error = 1.d0 real(kind=8), public :: y Source Code subroutine getdel1 ( Zc_in , del1_ini , del1 ) real ( 8 ), intent ( in ) :: Zc_in real ( 8 ), intent ( in ) :: del1_ini real ( 8 ), intent ( out ) :: del1 real ( 8 ) :: d1 , y , del1_old , Zc , Z_old , aux , error = 1.d0 del1 = del1_ini d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Zc = y / ( 3 * y + d1 - 1.0d0 ) del1_old = del1 if ( Zc . gt . Zc_in ) then del1 = 1.01 * del1 else del1 = 0.99 * del1 end if do while ( error >= 1.0d-6 ) d1 = ( 1 + del1 ** 2 ) / ( 1 + del1 ) y = 1 + ( 2 * ( 1 + del1 )) ** ( 1.0d0 / 3 ) + ( 4 / ( 1 + del1 )) ** ( 1.0d0 / 3 ) Z_old = Zc Zc = y / ( 3 * y + d1 - 1.0d0 ) aux = del1 del1 = del1 - ( Zc - Zc_in ) * ( del1 - del1_old ) / ( Zc - Z_old ) del1_old = aux error = abs ( Zc - Zc_in ) end do end subroutine getdel1","tags":"","loc":"proc/getdel1.html"},{"title":"pr_critical_from_params – fedebenelli/rkpr","text":"public subroutine pr_critical_from_params(ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Contents Variables OMa OMb Zc al be del1 ga Source Code pr_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: del1 = 1.0D0+sqrt(2.0) real(kind=8), public :: ga Source Code subroutine pr_critical_from_params ( ac , b , m , R , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0D0 + sqrt ( 2.0 ) real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * R * b ) Pc = OMb * R * Tc / b Vceos = Zc * R * Tc / Pc al = - 0.26992 be = 1.54226 ga = 0.37464 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine pr_critical_from_params","tags":"","loc":"proc/pr_critical_from_params.html"},{"title":"pr_params_from_crit – fedebenelli/rkpr","text":"public subroutine pr_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Contents Variables OMa OMb RT Vceos Zc del1 Source Code pr_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: RT real(kind=8), public :: Vceos real(kind=8), public :: Zc real(kind=8), public :: del1 = 1.0d0+sqrt(2.d0) Source Code subroutine pr_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc ! Critical temperature real ( 8 ), intent ( in ) :: Pc ! Critical pressure real ( 8 ), intent ( in ) :: w ! Accentric factor real ( 8 ), intent ( in ) :: R ! Gas constant real ( 8 ), intent ( out ) :: ac ! ac parameter real ( 8 ), intent ( out ) :: b ! Covolume real ( 8 ), intent ( out ) :: m ! Constant to calculate a(T) ! Internal varibles real ( 8 ) :: del1 = 1.0d0 + sqrt ( 2.d0 ) ! delta_1 for PR since the parameters are calculated based on the RKPR method real ( 8 ) :: OMa , OMb , Zc , Vceos ! real ( 8 ) :: RT ! R*T product RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc ! m constant to calculate a depending on temperature if ( w <= 0.491 ) then ! m from PR m = 0.37464 + 1.54226 * w - 0.26992 * w ** 2 end if if ( w > 0.491 ) then ! PR78 m = 0.379642 + 1.48503 * w - 0.164423 * w ** 2 + 0.016666 * w ** 3 end if end subroutine pr_params_from_crit","tags":"","loc":"proc/pr_params_from_crit.html"},{"title":"rkpr_critical_from_params – fedebenelli/rkpr","text":"public subroutine rkpr_critical_from_params(ac, b, del1, k, Tc, Pc, w, Vceos) Uses constants Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Contents Variables OMa OMb Zc al be ga Source Code rkpr_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: ga Source Code subroutine rkpr_critical_from_params ( ac , b , del1 , k , Tc , Pc , w , Vceos ) use constants real ( 8 ), intent ( in ) :: ac ! ac parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: del1 ! delta_1 parameter real ( 8 ), intent ( in ) :: k ! k parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! Accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume real ( 8 ) :: Zc , OMa , OMb , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = A1 * Zc + A0 be = B1 * Zc + B0 ga = C1 * Zc + C0 - k w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine rkpr_critical_from_params","tags":"","loc":"proc/rkpr_critical_from_params.html"},{"title":"rkpr_params_from_crit – fedebenelli/rkpr","text":"public subroutine rkpr_params_from_crit(Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate “a” with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 Contents Variables OMa OMb Pold Pv Pv_spec RHOL RHOV RHOld RT Tr Trho Zc a dc del1_old del1_spec del1ini delta_del1 delta_k oldk phiL rhoL_spec Source Code rkpr_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Pold real(kind=8), public :: Pv logical, public :: Pv_spec real(kind=8), public :: RHOL real(kind=8), public :: RHOV real(kind=8), public :: RHOld real(kind=8), public :: RT real(kind=8), public :: Tr real(kind=8), public :: Trho real(kind=8), public :: Zc real(kind=8), public :: a real(kind=8), public :: dc real(kind=8), public :: del1_old logical, public :: del1_spec real(kind=8), public :: del1ini real(kind=8), public :: delta_del1 real(kind=8), public :: delta_k real(kind=8), public :: oldk real(kind=8), public :: phiL logical, public :: rhoL_spec Source Code subroutine rkpr_params_from_crit ( & Tc , Pc , w , R , ac , b , k , del1 , Vceos , T , Pvdat , RhoLsat & ) !! Get the RKPR EOS parameters from the substance critical properties. ! Input real ( 8 ), intent ( in ) :: Tc !! Critical temperature real ( 8 ), intent ( in ) :: Pc !! Critical pressure real ( 8 ), intent ( in ) :: w !! accentric factor real ( 8 ), intent ( in ) :: R !! Gas constant ! Optional cases where extra specifications are made real ( 8 ), intent ( inout ), optional :: del1 !! delta_1 real ( 8 ), intent ( inout ), optional :: Vceos !! Critical volume at specification real ( 8 ), intent ( in ), optional :: T !! Temperature used to either estimate k or del1 real ( 8 ), intent ( inout ), optional :: Pvdat !! Vapor pressure used to estimate k real ( 8 ), intent ( in ), optional :: RhoLsat !! Saturation density used to estimate del1 !------------------------------------------------------------------------ real ( 8 ), intent ( out ) :: ac !! ac parameter real ( 8 ), intent ( out ) :: b !! covolume real ( 8 ), intent ( out ) :: k !! k to calculate \"a\" with ac and T real ( 8 ) :: OMa , OMb , Zc , RT , del1ini , dc , Tr , & a , Pv , RHOL , RHOV , phiL , delta_k , Pold , oldk , & Trho , RHOld , del1_old , delta_del1 logical :: del1_spec , Pv_spec , rhoL_spec del1_spec = . false . Pv_spec = . false . rhoL_spec = . false . if ( present ( del1 )) then del1_spec = . true . !print *, \"Specified del1\" end if if ( present ( T )) then if ( present ( Pvdat )) then Pv_spec = . true . !print *, \"Specified Pv\" end if end if if ( present ( T )) then if ( present ( RhoLsat )) then rhoL_spec = . true . !print *, \"Specified RhoLsat\" end if end if ! Initialize delta_1 and get the value that statisfies the Zc ! condition ! ----------------------------------------------------------------------- RT = R * Tc if ( present ( Vceos )) then ! Usual specification with Vceos Zc = Pc * Vceos / RT del1ini = D ( 1 ) + D ( 2 ) * ( D ( 3 ) - Zc ) ** D ( 4 ) + D ( 5 ) * ( D ( 3 ) - Zc ) ** D ( 6 ) call getdel1 ( Zc , del1ini , del1 ) end if if ( rhoL_spec ) then Trho = T / Tc del1 = 2.0 ! initial value RHOld = 0.d0 end if ! Calculate the inbetween parameters and finally get ac and b ! ----------------------------------------------------------------------- 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc ! Obtain the k parameter ! ----------------------------------------------------------------------- dc = Pc / Zc / RT Vceos = 1.0d0 / dc ! initial guess for k parameter k = ( A1 * Zc + A0 ) * w ** 2 + ( B1 * Zc + B0 ) * w + ( C1 * Zc + C0 ) a = ac * ( 3 / ( 2 + Tr )) ** k if ( del1_spec ) then Vceos = Zc * RT / Pc end if if ( Pv_spec ) then ! added 29/06/2013 in order to allow for better reproductions of Pv curves Tr = T / Tc else Tr = 0.7d0 Pvdat = Pc * 10 **- ( 1.0d0 + w ) end if ! Find the value of k that fits with the expected Pv call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) if ( Pv > Pvdat ) then delta_k = 0.1 else delta_k = - 0.1 end if do while ( abs ( Pv - Pvdat ) / Pvdat > 0.005 ) Pold = Pv oldk = k k = k + delta_k a = ac * ( 3 / ( 2 + Tr )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Tr , Pvdat , Pv , RHOL , RHOV , phiL ) delta_k = - ( Pv - Pvdat ) * ( k - oldk ) / ( Pv - Pold ) end do if ( rhoL_spec ) then ! November 2011 for RKPR specifying T, RHOLsat if ( abs ( Trho - 0.70 ) > 1.d-2 ) then ! get calculated RHOL when Trho is no 0.70 Pvdat = Pc * 10 **- (( 1. / Trho - 1 d0 ) * 7 * ( 1.0D0 + w ) / 3 ) a = ac * ( 3 / ( 2 + Trho )) ** k call VaporPressure ( a , b , del1 , Tc , dc , Trho , Pvdat , Pv , RHOL , RHOV , phiL ) end if if ( RHOld == 0.d0 ) then del1_old = del1 ! condition for the strange case that del1=2 is solution if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) del1 = 2.1 else delta_del1 = - ( RHOL - RhoLsat ) * ( del1 - del1_old ) / ( RHOL - RHOld ) del1_old = del1 del1 = del1 + delta_del1 end if RHOld = RHOL if ( abs ( RHOL - RHOLSAT ) / RHOLSAT > 1.d-4 ) go to 17 call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc end if end subroutine rkpr_params_from_crit","tags":"","loc":"proc/rkpr_params_from_crit.html"},{"title":"srk_critical_from_params – fedebenelli/rkpr","text":"public subroutine srk_critical_from_params(ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos Contents Variables OMa OMb Zc al be del1 ga Source Code srk_critical_from_params Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: Zc real(kind=8), public :: al real(kind=8), public :: be real(kind=8), public :: del1 = 1.0d0 real(kind=8), public :: ga Source Code subroutine srk_critical_from_params ( ac , b , m , Tc , Pc , w , Vceos ) real ( 8 ), intent ( in ) :: ac ! a parameter real ( 8 ), intent ( in ) :: b ! b parameter real ( 8 ), intent ( in ) :: m ! m parameter real ( 8 ), intent ( out ) :: Tc ! Critical temperature real ( 8 ), intent ( out ) :: Pc ! Critical pressure real ( 8 ), intent ( out ) :: w ! accentric factor real ( 8 ), intent ( out ) :: Vceos ! Critical volume according to eos real ( 8 ) :: del1 = 1.0d0 real ( 8 ) :: OMa , OMb , Zc , al , be , ga call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) Tc = OMb * ac / ( OMa * RGAS * b ) Pc = OMb * RGAS * Tc / b Vceos = Zc * RGAS * Tc / Pc al = - 0.175 be = 1.574 ga = 0.48 - m w = 0.5 * ( - be + sqrt ( be ** 2 - 4 * al * ga )) / al end subroutine srk_critical_from_params","tags":"","loc":"proc/srk_critical_from_params.html"},{"title":"srk_params_from_crit – fedebenelli/rkpr","text":"public subroutine srk_params_from_crit(Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m Contents Variables OMa OMb RT Vceos Zc del1 Source Code srk_params_from_crit Variables Type Visibility Attributes Name Initial real(kind=8), public :: OMa real(kind=8), public :: OMb real(kind=8), public :: RT real(kind=8), public :: Vceos real(kind=8), public :: Zc real(kind=8), public :: del1 = 1.0D0 Source Code subroutine srk_params_from_crit ( Tc , Pc , w , R , ac , b , m ) real ( 8 ), intent ( in ) :: Tc real ( 8 ), intent ( in ) :: Pc real ( 8 ), intent ( out ) :: w real ( 8 ), intent ( in ) :: R real ( 8 ), intent ( out ) :: ac real ( 8 ), intent ( out ) :: b real ( 8 ), intent ( out ) :: m real ( 8 ) :: del1 = 1.0D0 real ( 8 ) :: OMa , OMb , Zc , Vceos real ( 8 ) :: RT RT = R * Tc call get_Zc_OMa_OMb ( del1 , Zc , OMa , OMb ) ac = OMa * RT ** 2 / Pc b = OMb * RT / Pc Vceos = Zc * R * Tc / Pc m = 0.48 + 1.574 * w - 0.175 * w ** 2 end subroutine srk_params_from_crit","tags":"","loc":"proc/srk_params_from_crit.html"},{"title":"vdWg_Derivs – fedebenelli/rkpr","text":"public subroutine vdWg_Derivs(a, b, del1, T, V, F, F_V, F_2V, F_N) Uses constants Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N Contents Variables ATT ATT2V ATTV C ETA REP REP2V REPV SUMC SUMD aRT Variables Type Visibility Attributes Name Initial real(kind=8), public :: ATT real(kind=8), public :: ATT2V real(kind=8), public :: ATTV real(kind=8), public :: C real(kind=8), public :: ETA real(kind=8), public :: REP real(kind=8), public :: REP2V real(kind=8), public :: REPV real(kind=8), public :: SUMC real(kind=8), public :: SUMD real(kind=8), public :: aRT","tags":"","loc":"proc/vdwg_derivs.html"},{"title":"constants – fedebenelli/rkpr","text":"Contents Variables A0 A1 B0 B1 C0 C1 D ERRMAX RGAS wp Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: A0 = 0.0017 real(kind=wp), public, parameter :: A1 = -2.4407 real(kind=wp), public, parameter :: B0 = 1.9681 real(kind=wp), public, parameter :: B1 = 7.4513 real(kind=wp), public, parameter :: C0 = -2.7238 real(kind=wp), public, parameter :: C1 = 12.504 real(kind=wp), public, dimension(6) :: D = [0.428363, 18.496215, 0.338426, 0.660, 789.723105, 2.512392] real(kind=wp), public, parameter :: ERRMAX = 1.D-8 real(kind=wp), public, parameter :: RGAS = 0.08314472d0 integer, public, parameter :: wp = 8","tags":"","loc":"module/constants.html"},{"title":"cubic_eos – fedebenelli/rkpr","text":"Module that encompass the calculations of the residual Helmholtz energy\nand related properties like fugacity coefficents. Uses constants Contents Subroutines Bmixnder aTder aijTder amixTnder d1nder helmholtz_energy helmholtz_energy_RKPR kij_tdep Subroutines public subroutine Bmixnder (nc, n, bij, B_mix, dBdni, dB2dnij2) Repulsive parameter of the mixture and it’s compositional derivatives. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc real(kind=wp), intent(in) :: n (nc) real(kind=wp), intent(in) :: bij (nc,nc) real(kind=wp), intent(out) :: B_mix real(kind=wp), intent(out) :: dBdni (nc) real(kind=wp), intent(out) :: dB2dnij2 (nc,nc) public subroutine aTder (T, a, dadT, dadT2) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: a (nc) Atractive parameter at T real(kind=wp), intent(out) :: dadT (nc) First deritvative with T real(kind=wp), intent(out) :: dadT2 (nc) Second derivative with T public subroutine aijTder (T, aij, daijdT, daij2dT2) Calculate the binary atractive term matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: aij (nc,nc) Atractive binary terms matrix real(kind=wp), intent(out) :: daijdT (nc,nc) Atractive binary terms matrix first derivative with temperature real(kind=wp), intent(out) :: daij2dT2 (nc,nc) Atractive binary terms matrix second derivative with temperature public subroutine amixTnder (nc, T, n, a, dadni, da2dniT2, da2dnij2, dadT, da2dT2) Atractive parameter of a mixture and it’s derivatives Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(in) :: n (nc) Matrix with number of moles real(kind=wp), intent(out) :: a Mixture atractive parameter real(kind=wp), intent(out) :: dadni (nc) Atractive parameter first derivative with number of moles real(kind=wp), intent(out) :: da2dniT2 (nc) Atractive parameter second derivative with moles and Tempeature real(kind=wp), intent(out) :: da2dnij2 (nc,nc) Atractive parameter second derivative with number of moles real(kind=wp), intent(out) :: dadT (nc) Atractive parameter first derivative with Tempeature real(kind=wp), intent(out) :: da2dT2 (nc) Atractive parameter first derivative with Tempeature public subroutine d1nder (nc, n, d1, d1_mix, dD1dni, dD12dnij2) Delta_1 of the mixture and compositional derivatives. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components. real(kind=wp), intent(in) :: n (nc) Array of mole numbers for each component. real(kind=wp), intent(in) :: d1 (nc) Array of delta 1 parameters for each component. real(kind=wp), intent(out) :: d1_mix ?? real(kind=wp), intent(out) :: dD1dni (nc) delta1 parameter first derivative with composition. real(kind=wp), intent(out) :: dD12dnij2 (nc,nc) delta1 parameter second derivative with composition. public subroutine helmholtz_energy (nc, ND, NT, n, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components integer, intent(in) :: ND integer, intent(in) :: NT real(kind=wp), intent(in) :: n (nc) Number of moles real(kind=wp), intent(in) :: V real(kind=wp), intent(in) :: T real(kind=wp), intent(out) :: Ar real(kind=wp), intent(out) :: ArV real(kind=wp), intent(out) :: ArTV real(kind=wp), intent(out) :: ArV2 real(kind=wp), intent(out) :: Arn (nc) real(kind=wp), intent(out) :: ArVn (nc) real(kind=wp), intent(out) :: ArTn (nc) real(kind=wp), intent(out) :: Arn2 (nc,nc) public subroutine helmholtz_energy_RKPR (nco, NDE, NTD, rn, V, T, Ar, ArV, ArTV, ArV2, Arn, ArVn, ArTn, Arn2) Calculate the reduced residual Helmholtz Energy and it’s derivatives with the RKPR EOS Arguments Type Intent Optional Attributes Name integer :: nco integer :: NDE integer :: NTD real :: rn real :: V real :: T real :: Ar real :: ArV real :: ArTV real :: ArV2 real :: Arn real :: ArVn real :: ArTn real :: Arn2 public subroutine kij_tdep (T, kij, dkijdt, dkij2dt2) Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out) :: kij (nc,nc) Binary interaction parameter matrix real(kind=wp), intent(out) :: dkijdt (nc,nc) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out) :: dkij2dt2 (nc,nc) Binary interaction parameter second derivative with T matrix","tags":"","loc":"module/cubic_eos.html"},{"title":"datatypes – fedebenelli/rkpr","text":"Uses constants Contents Derived Types compound mix Derived Types type, public :: compound Components Type Visibility Attributes Name Initial real(kind=wp), public :: ac real(kind=wp), public :: b real(kind=wp), public :: k real(kind=wp), public :: pc real(kind=wp), public :: tc real(kind=wp), public :: w type, public :: mix Components Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:), allocatable :: n Number of moles character(len=:), public, dimension(:), allocatable :: names Components names integer, public :: nc Number of components integer, public :: ncomb Combining rule integer, public :: nmodel Model to use integer, public :: ntdep Temperature dependence real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: w Accentric factors","tags":"","loc":"module/datatypes.html"},{"title":"mixture – fedebenelli/rkpr","text":"Module to represent a mixture of fluids, it’s used to save the\nmultiple component’s properties to be used by different subroutines.\nIt also includes a set of subroutines to read the data and save it\nin the module. System of units: This units are asumed, if the user wants to use another\nsystem, the RGAS constant should be changed at the module constants Volume: Liter Pressure: bar Temperature: Kelvin Uses constants Contents Variables T_star ac aij b dc del1 k kij kij_0 kij_inf lij n names nc ncomb nmodel ntdep pc tc w Subroutines setup Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(:, :), allocatable :: T_star Reference temperature for temperature dependent Kij real(kind=wp), public, dimension(:), allocatable :: ac EOS atractive parameter real(kind=wp), public, dimension(:, :), allocatable :: aij EOS atractive parameter matrix real(kind=wp), public, dimension(:), allocatable :: b EOS repulsive parameter real(kind=wp), public, dimension(:), allocatable :: dc Critical Densities (from EOS) real(kind=wp), public, dimension(:), allocatable :: del1 EOS delta_1 real(kind=wp), public, dimension(:), allocatable :: k k parameter to calculate the a parameter real(kind=wp), public, dimension(:, :), allocatable :: kij Kij matrix real(kind=wp), public, dimension(:, :), allocatable :: kij_0 Kij standard real(kind=wp), public, dimension(:, :), allocatable :: kij_inf Kij at infinite temperature real(kind=wp), public, dimension(:, :), allocatable :: lij lij matrix real(kind=wp), public, dimension(:), allocatable :: n Number of moles character(len=:), public, dimension(:), allocatable :: names Components names integer, public :: nc Number of components integer, public :: ncomb Combining rule integer, public :: nmodel Model to use integer, public :: ntdep Temperature dependence real(kind=wp), public, dimension(:), allocatable :: pc Critical Pressures real(kind=wp), public, dimension(:), allocatable :: tc Critical Temperatures real(kind=wp), public, dimension(:), allocatable :: w Accentric factors Subroutines public subroutine setup (nin, filename) This subroutine will be used to read data files and get the\nmixture properties Arguments Type Intent Optional Attributes Name integer, intent(in) :: nin character(len=:), intent(in), allocatable :: filename","tags":"","loc":"module/mixture.html"},{"title":"rkpr – fedebenelli/rkpr","text":"Uses constants Contents None","tags":"","loc":"module/rkpr.html"},{"title":"mixing_rules – fedebenelli/rkpr","text":"Module that contains the available mixing rules to be used. Uses constants Contents Subroutines other quadratic Subroutines public subroutine other (nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) What’s this?? Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix public subroutine quadratic (nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix","tags":"","loc":"module/mixing_rules.html"},{"title":"parameters – fedebenelli/rkpr","text":"Uses iso_fortran_env Contents Variables Tc a b dc del1 Variables Type Visibility Attributes Name Initial real(kind=8), public, save :: Tc real(kind=8), public, save :: a real(kind=8), public, save :: b real(kind=8), public, save :: dc real(kind=8), public, save :: del1","tags":"","loc":"module/parameters.html"},{"title":"converter – fedebenelli/rkpr","text":"Uses constants iso_fortran_env Contents Subroutines FUG_CALC VCALC VaporPressure get_Zc_OMa_OMb getdel1 pr_critical_from_params pr_params_from_crit rkpr_critical_from_params rkpr_params_from_crit srk_critical_from_params srk_params_from_crit vdWg_Derivs Subroutines public subroutine FUG_CALC (a, b, del1, T, P, V, phi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(in) :: V real(kind=8), intent(out) :: phi public recursive subroutine VCALC (ITYP, a, b, del1, T, P, V) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ITYP real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: P real(kind=8), intent(out) :: V public recursive subroutine VaporPressure (a, b, del1, Tc, dc, Tr, PVini, Pv, RHOL, RHOV, phiL) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: dc real(kind=8), intent(in) :: Tr real(kind=8), intent(in) :: PVini real(kind=8), intent(out) :: Pv real(kind=8), intent(out) :: RHOL real(kind=8), intent(out) :: RHOV real(kind=8), intent(out) :: phiL public subroutine get_Zc_OMa_OMb (del1, Zc, OMa, OMb) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: del1 real(kind=8), intent(out) :: Zc real(kind=8), intent(out) :: OMa real(kind=8), intent(out) :: OMb public subroutine getdel1 (Zc_in, del1_ini, del1) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Zc_in real(kind=8), intent(in) :: del1_ini real(kind=8), intent(out) :: del1 public subroutine pr_critical_from_params (ac, b, m, R, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(in) :: R real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine pr_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(in) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine rkpr_critical_from_params (ac, b, del1, k, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: k real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine rkpr_params_from_crit (Tc, Pc, w, R, ac, b, k, del1, Vceos, T, Pvdat, RhoLsat) Get the RKPR EOS parameters from the substance critical properties. Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc Critical temperature real(kind=8), intent(in) :: Pc Critical pressure real(kind=8), intent(in) :: w accentric factor real(kind=8), intent(in) :: R Gas constant real(kind=8), intent(out) :: ac ac parameter real(kind=8), intent(out) :: b covolume real(kind=8), intent(out) :: k k to calculate “a” with ac and T real(kind=8), intent(inout), optional :: del1 delta_1 real(kind=8), intent(inout), optional :: Vceos Critical volume at specification real(kind=8), intent(in), optional :: T Temperature used to either estimate k or del1 real(kind=8), intent(inout), optional :: Pvdat Vapor pressure used to estimate k real(kind=8), intent(in), optional :: RhoLsat Saturation density used to estimate del1 public subroutine srk_critical_from_params (ac, b, m, Tc, Pc, w, Vceos) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ac real(kind=8), intent(in) :: b real(kind=8), intent(in) :: m real(kind=8), intent(out) :: Tc real(kind=8), intent(out) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(out) :: Vceos public subroutine srk_params_from_crit (Tc, Pc, w, R, ac, b, m) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Tc real(kind=8), intent(in) :: Pc real(kind=8), intent(out) :: w real(kind=8), intent(in) :: R real(kind=8), intent(out) :: ac real(kind=8), intent(out) :: b real(kind=8), intent(out) :: m public subroutine vdWg_Derivs (a, b, del1, T, V, F, F_V, F_2V, F_N) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(in) :: del1 real(kind=8), intent(in) :: T real(kind=8), intent(in) :: V real(kind=8), intent(out) :: F real(kind=8), intent(out) :: F_V real(kind=8), intent(out) :: F_2V real(kind=8), intent(out) :: F_N","tags":"","loc":"module/converter.html"},{"title":"main – fedebenelli/rkpr","text":"Uses json_module Contents Variables found i id json_data kij kijs n name z Source Code main Variables Type Attributes Name Initial logical :: found integer :: i character(len=50) :: id type(json_file) :: json_data real(kind=8), allocatable :: kij (:) real(kind=8), allocatable :: kijs (:,:) integer :: n character(len=:), allocatable :: name real(kind=8), allocatable :: z (:) Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"program/main.html"}]}