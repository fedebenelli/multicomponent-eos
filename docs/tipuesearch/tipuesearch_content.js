var tipuesearch = {"pages":[{"title":" Multicomponent Equations of State ","text":"Multicomponent Equations of State Fortran program for the calculation of the residual Helmholtz Energy using the\nRKPR EoS (hence, PR and SRK are also included), for multicomponent mixtures. Developer Info Federico Benelli Doctoral student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"constants.f90 – Multicomponent Equations of State","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~rkpr.f90 rkpr.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants implicit none integer , parameter :: wp = 8 real ( wp ), parameter :: RGAS = 0.08314472d0 real ( wp ), parameter :: A0 = 0.0017 , B0 = 1.9681 , C0 = - 2.7238 real ( wp ), parameter :: A1 = - 2.4407 , B1 = 7.4513 , C1 = 1 2.504 real ( wp ), dimension ( 6 ) :: Dfit = [ 0.428363 , 1 8.496215 , 0.338426 , & 0.660 , 78 9.723105 , 2.512392 ] real ( wp ), parameter :: ERRMAX = 1.D-8 end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"cubic_eos.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~cubic_eos.f90~~EfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~cubic_eos.f90~~AfferentGraph sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules cubic_eos Source Code cubic_eos.f90 Source Code module cubic_eos !! Module that encompass the calculations of the residual Helmholtz energy !! and related properties like fugacity coefficents. use constants use mixing_rules implicit none type :: pure_compound !! Generic EoS character ( len = 100 ) :: name !! Compound name real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ), private :: del1 = 1 !! \\delta_1 parameter. end type pr type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ), private :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr contains subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter !subroutine aijTder(nc, ac, tc, k, T, kij_calc, aij, daijdT, daij2dT2) !   !! Calculate the binary atractive term matrix !   implicit none !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   class(*) :: kij_calc !! Kij calculator object !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(out) :: aij(nc, nc) !! Atractive binary terms matrix !   real(wp), intent(out) :: daijdT(nc, nc) !! Atractive binary terms matrix first derivative with temperature !   real(wp), intent(out) :: daij2dT2(nc, nc) !! Atractive binary terms matrix second derivative with temperature !   real(wp), allocatable :: kij(:, :), dkijdt(:, :), dkij2dt2(:, :) ! kij and T derivatives !   real(wp) :: a(nc), dadT(nc), da2dT2(nc) ! Atractive parameter and T derivatives !   real(wp) :: b(nc), bij(nc, nc) ! Repulsive parameter (just to use as input in subroutine) !   b = 0  ! Here only the aij for the mixture, so there is no need to use the real b !   ! Calculate pure compounds atractive parameters at T !   call aTder(nc, ac, k, tc, T, a, dadT, da2dT2) !   select type (kij_calc) !   type is (kij_constant) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   type is (kij_exp_t) !      call kij_calc%get_kij(T, kij, dkijdt, dkij2dt2) !   end select !end subroutine aijTder !subroutine DmixTnder(& !        nc, ac, tc, k, & !        T, n, & !        D, dDdni, dD2dniT2, dD2dnij2, dDdT, dD2dT2) !   !! Atractive parameter of a mixture and it's derivatives !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: ac(nc) !! Critical atractive parameters !   real(wp), intent(in) :: tc(nc) !! Critical temperatures !   real(wp), intent(in) :: k(nc) !! Accentric factor related constant !   real(wp), intent(in) :: T !! Temperature !   real(wp), intent(in) :: n(nc) !! Matrix with number of moles !   real(wp), intent(out) :: D !! Mixture atractive parameter (times moles&#94;2) !   real(wp), intent(out) :: dDdni(nc) !! Atractive parameter first derivative with number of moles !   real(wp), intent(out) :: dD2dniT2(nc) !! Atractive parameter second derivative with moles and Tempeature !   real(wp), intent(out) :: dD2dnij2(nc, nc) !! Atractive parameter second derivative with number of moles !   real(wp), intent(out) :: dDdT(nc) !! Atractive parameter first derivative with Tempeature !   real(wp), intent(out) :: dD2dT2(nc) !! Atractive parameter first derivative with Tempeature !   real(wp) :: aij(nc, nc), daijdT(nc, nc), daij2dT2(nc, nc) !   real(wp) :: aux, aux2 !   integer :: i, j !   ! TODO: An already calculated aij matrix could be the input !   call aijTder(nc, ac, tc, k, T, aij, daijdT, daij2dT2) !   D = 0.0_wp !   dDdT = 0.0_wp !   dD2dT2 = 0.0_wp !   do i = 1, nc !      aux = 0.0_wp !      aux2 = 0.0_wp !      dDdni(i) = 0.0_wp !      dD2dniT2(i) = 0.0_wp !      do j = 1, nc !         dDdni(i) = dDdni(i) + 2*n(j)*aij(i, j) !         dD2dniT2(i) = dD2dniT2(i) + 2*n(j)*daijdT(i, j) !         dD2dnij2(i, j) = 2*aij(i, j) !         aux = aux + n(j)*aij(i, j) !         aux2 = aux2 + n(j)*daij2dT2(i, j) !      end do !      D = D + n(i)*aux !      dDdT = dDdT + n(i)*dD2dniT2(i)/2 !      dD2dT2 = dD2dT2 + n(i)*aux2 !   end do !end subroutine DmixTnder !subroutine d1nder(nc, n, d1, d1_mix, dD1dni, dD12dnij2) !   !! delta_1 of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components. !   real(wp), intent(in) :: n(nc) !! Array of mole numbers for each component. !   real(wp), intent(in) :: d1(nc) !! Array of delta 1 parameters for each component. !   real(wp), intent(out) :: d1_mix !! Mixture's delta 1 !   real(wp), intent(out) :: dD1dni(nc) !! delta1 parameter first derivative with composition. !   real(wp), intent(out) :: dD12dnij2(nc, nc) !! delta1 parameter second derivative with composition. !   integer :: i, j !   real(wp) :: totn ! Total number of moles !   d1_mix = 0.0_wp !   d1_mix = sum(n*d1) !   totn = sum(n) !   D1_mix = D1_mix/totn !   dD1dni = (d1 - d1_mix)/totn !   do i = 1, nc !      do j = 1, nc !         dD12dnij2(i, j) = (2.0_wp*d1_mix - d1(i) - d1(j))/totn**2 !      end do !   end do !end subroutine d1nder !subroutine Bmixnder(nc, n, bij, B_mix, dBdni, dB2dnij2) !   !! Repulsive parameter of the mixture and it's compositional derivatives. !   integer, intent(in) :: nc !! Number of components !   real(wp), intent(in) :: n(nc) !! Number of moles of each component !   real(wp), intent(in) :: bij(nc, nc) !! Repulsive parameter matrix !   real(wp), intent(out) :: B_mix !! Mixture repulsive parameter !   real(wp), intent(out) :: dBdni(nc) !! Repulsive parameter derivatives wrt number of moles !   real(wp), intent(out) :: dB2dnij2(nc, nc) !! Repulsive parameter second derivatives wrt number of moles !   real(wp) :: totn, aux(nc) !   integer :: i, j !   totn = sum(n) !   B_mix = 0.0_wp !   aux = 0.0_wp !   do i = 1, nc !      do j = 1, nc !         aux(i) = aux(i) + n(j)*bij(i, j) !      end do !      B_mix = B_mix + n(i)*aux(i) !   end do !   B_mix = B_mix/totn !   do i = 1, nc !      dBdni(i) = (2*aux(i) - B_mix)/totn !      do j = 1, i !         dB2dnij2(i, j) = (2*bij(i, j) - dBdni(i) - dBdni(j))/totn !         dB2dnij2(j, i) = dB2dnij2(i, j) !      end do !   end do !end subroutine Bmixnder end module cubic_eos","tags":"","loc":"sourcefile/cubic_eos.f90.html"},{"title":"mixture.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixture.f90~~EfferentGraph sourcefile~mixture.f90 mixture.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixture.f90->sourcefile~constants.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~cubic_eos.f90->sourcefile~constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules multicomponent_eos Source Code mixture.f90 Source Code module multicomponent_eos use constants use mixing_rules use cubic_eos implicit none type :: mixture class ( pure_compound ), allocatable :: compounds (:) class ( kij_constant ), allocatable :: kij_calculator class ( lij_constant ), allocatable :: lij_calculator real ( wp ), allocatable :: kij_matrix (:, :) real ( wp ), allocatable :: lij_matrix (:, :) real ( wp ), allocatable :: aij (:, :) real ( wp ), allocatable :: bij (:, :) contains procedure :: mix => mix end type mixture contains subroutine mix ( self , T ) class ( mixture ) :: self !! Mixture object real ( wp ), intent ( in ) :: T !! Temperature [K] real ( wp ), allocatable :: a (:) real ( wp ), allocatable :: dadt (:) real ( wp ), allocatable :: da2dt2 (:) real ( wp ), allocatable :: b (:), bij (:, :), lij (:, :) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , nc nc = size ( self % compounds ) ! ======================================================================= !   Calculate all the pure compounds atractive and repulsive !    parameters at T ! ----------------------------------------------------------------------- allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) do i = 1 , nc call self % compounds ( i )% a_t ( T ) a ( i ) = self % compounds ( i )% a dadt ( i ) = self % compounds ( i )% dadt da2dt2 ( i ) = self % compounds ( i )% da2dt2 b ( i ) = self % compounds ( i )% b end do ! ======================================================================= ! ======================================================================= !  Calculate the kij and lij matrices ! ----------------------------------------------------------------------- associate ( kij_rule => self % kij_calculator ) select type ( kij_rule ) type is ( kij_constant ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) type is ( kij_exp_t ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) class default print * , \"Not implemented Kij rule\" end select end associate associate ( lij_rule => self % lij_calculator ) select type ( lij_rule ) type is ( lij_constant ) call lij_rule % get_lij ( T , lij ) class default print * , \"Not implemented Kij rule\" end select self % kij_matrix = kij self % lij_matrix = lij end associate ! ======================================================================= ! ======================================================================= ! Calculate each aij ! ----------------------------------------------------------------------- allocate ( self % aij ( nc , nc )) allocate ( self % bij ( nc , nc )) do i = 1 , nc self % aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) self % bij ( i , :) = ( 1 - lij ( i , :)) * ( b ( i ) + b (:)) / 2 end do ! ======================================================================= end subroutine mix end module multicomponent_eos","tags":"","loc":"sourcefile/mixture.f90.html"},{"title":"rkpr.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~rkpr.f90~~EfferentGraph sourcefile~rkpr.f90 rkpr.f90 sourcefile~constants.f90 constants.f90 sourcefile~rkpr.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rkpr Source Code rkpr.f90 Source Code module rkpr use constants implicit none contains end module rkpr","tags":"","loc":"sourcefile/rkpr.f90.html"},{"title":"mixing_rules.f90 – Multicomponent Equations of State","text":"This file depends on sourcefile~~mixing_rules.f90~~EfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~constants.f90 constants.f90 sourcefile~mixing_rules.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mixing_rules.f90~~AfferentGraph sourcefile~mixing_rules.f90 mixing_rules.f90 sourcefile~cubic_eos.f90 cubic_eos.f90 sourcefile~cubic_eos.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90 mixture.f90 sourcefile~mixture.f90->sourcefile~mixing_rules.f90 sourcefile~mixture.f90->sourcefile~cubic_eos.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mixing_rules Source Code mixing_rules.f90 Source Code module mixing_rules !! Module that contains the available mixing rules to be used. use constants implicit none type :: kij_constant !! K_ij constant type real ( wp ), allocatable :: kij (:, :) !! K_ij matrix contains procedure :: get_kij => kij_const end type type , extends ( kij_constant ) :: kij_exp_t !! Kij with temperature dependance according to the equation: !!  K_{ij}(T) = K_{ij\\infty} + K_{ij0} e&#94;{-T/T&#94;*}  !! The parameters of the equation are obtained from the mixture module. real ( wp ), allocatable :: dkijdt (:, :) !! K_ij matrix real ( wp ), allocatable :: dkij2dt2 (:, :) !! K_ij matrix real ( wp ), allocatable :: kij_0 (:, :) !! Exponential real ( wp ), allocatable :: kij_inf (:, :) !! K_ij at infinite Temperature real ( wp ), allocatable :: T_star (:, :) !! Reference temperature contains procedure :: get_kij => kij_tdep end type type :: lij_constant !! Constant l_{ij} real ( wp ), allocatable :: lij (:, :) !! l_{ij} values contains procedure :: get_lij => lij_const end type lij_constant contains subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep subroutine kij_const ( self , T , kij , dkijdt , dkij2dt2 ) class ( kij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix kij = self % kij dkijdt = 0 * kij dkij2dt2 = 0 * kij end subroutine kij_const subroutine lij_const ( self , T , lij ) class ( lij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: lij (:, :) !! Binary repulsive parameter matrix lij = self % lij end subroutine lij_const subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic end module mixing_rules","tags":"","loc":"sourcefile/mixing_rules.f90.html"},{"title":"main.f90 – Multicomponent Equations of State","text":"Contents Programs main Source Code main.f90 Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"pr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Inherits type~~pr~~InheritsGraph type~pr pr type~pure_compound pure_compound type~pr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k name pc tc w Type-Bound Procedures a_t Source Code pr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: pr !! Peng-Robinson EoS real ( 8 ), private :: del1 = 1 !! \\delta_1 parameter. end type pr","tags":"","loc":"type/pr.html"},{"title":"pure_compound – Multicomponent Equations of State ","text":"type, public :: pure_compound Generic EoS Inherited by type~~pure_compound~~InheritedByGraph type~pure_compound pure_compound type~pr pr type~pr->type~pure_compound type~mixture mixture type~mixture->type~pure_compound compounds type~srk srk type~srk->type~pure_compound type~rkpr rkpr type~rkpr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k name pc tc w Type-Bound Procedures a_t Source Code pure_compound Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type :: pure_compound !! Generic EoS character ( len = 100 ) :: name !! Compound name real ( 8 ) :: ac !! Critical atractive parameter real ( 8 ) :: b !! Repulsive parameter real ( 8 ) :: tc !! Critical temperature real ( 8 ) :: pc !! Critical pressure real ( 8 ) :: w !! Accentric factor real ( 8 ) :: k !! Atractive parameter constant real ( 8 ) :: a = 0 !! Atractive parameter valuated at temperature real ( 8 ) :: dadt = 0 !! Atractive parameter first derivative with tempetarue real ( 8 ) :: da2dt2 = 0 !! Atractive parameter second derivative with tempetarue contains procedure :: a_t => a_parameter end type pure_compound","tags":"","loc":"type/pure_compound.html"},{"title":"rkpr – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: rkpr Inherits type~~rkpr~~InheritsGraph type~rkpr rkpr type~pure_compound pure_compound type~rkpr->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt del1 k name pc tc w Type-Bound Procedures a_t Source Code rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: rkpr real ( 8 ) :: del1 end type rkpr","tags":"","loc":"type/rkpr.html"},{"title":"srk – Multicomponent Equations of State ","text":"type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Inherits type~~srk~~InheritsGraph type~srk srk type~pure_compound pure_compound type~srk->type~pure_compound Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a ac b da2dt2 dadt k name pc tc w Type-Bound Procedures a_t Source Code srk Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Source Code type , extends ( pure_compound ) :: srk !! Soave-Redlich-Kwong EoS real ( 8 ), private :: del1 = 1 + sqrt ( 2.d0 ) !! \\delta_1 parameter. end type srk","tags":"","loc":"type/srk.html"},{"title":"mixture – Multicomponent Equations of State ","text":"type, public :: mixture Inherits type~~mixture~~InheritsGraph type~mixture mixture type~pure_compound pure_compound type~mixture->type~pure_compound compounds type~kij_constant kij_constant type~mixture->type~kij_constant kij_calculator type~lij_constant lij_constant type~mixture->type~lij_constant lij_calculator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables aij bij compounds kij_calculator kij_matrix lij_calculator lij_matrix Type-Bound Procedures mix Source Code mixture Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) real(kind=wp), public, allocatable :: bij (:,:) class( pure_compound ), public, allocatable :: compounds (:) class( kij_constant ), public, allocatable :: kij_calculator real(kind=wp), public, allocatable :: kij_matrix (:,:) class( lij_constant ), public, allocatable :: lij_calculator real(kind=wp), public, allocatable :: lij_matrix (:,:) Type-Bound Procedures procedure, public :: mix public subroutine mix (self, T) Arguments Type Intent Optional Attributes Name class( mixture ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K] Source Code type :: mixture class ( pure_compound ), allocatable :: compounds (:) class ( kij_constant ), allocatable :: kij_calculator class ( lij_constant ), allocatable :: lij_calculator real ( wp ), allocatable :: kij_matrix (:, :) real ( wp ), allocatable :: lij_matrix (:, :) real ( wp ), allocatable :: aij (:, :) real ( wp ), allocatable :: bij (:, :) contains procedure :: mix => mix end type mixture","tags":"","loc":"type/mixture.html"},{"title":"kij_constant – Multicomponent Equations of State ","text":"type, public :: kij_constant constant type Inherited by type~~kij_constant~~InheritedByGraph type~kij_constant kij_constant type~mixture mixture type~mixture->type~kij_constant kij_calculator type~kij_exp_t kij_exp_t type~kij_exp_t->type~kij_constant Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables kij Type-Bound Procedures get_kij Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: kij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_const public subroutine kij_const (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix","tags":"","loc":"type/kij_constant.html"},{"title":"kij_exp_t – Multicomponent Equations of State ","text":"type, public, extends( kij_constant ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Inherits type~~kij_exp_t~~InheritsGraph type~kij_exp_t kij_exp_t type~kij_constant kij_constant type~kij_exp_t->type~kij_constant Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables T_star dkij2dt2 dkijdt kij kij_0 kij_inf Type-Bound Procedures get_kij Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature Type-Bound Procedures procedure, public :: get_kij => kij_tdep public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix","tags":"","loc":"type/kij_exp_t.html"},{"title":"lij_constant – Multicomponent Equations of State ","text":"type, public :: lij_constant Constant Inherited by type~~lij_constant~~InheritedByGraph type~lij_constant lij_constant type~mixture mixture type~mixture->type~lij_constant lij_calculator Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lij Type-Bound Procedures get_lij Source Code lij_constant Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: lij (:,:) values Type-Bound Procedures procedure, public :: get_lij => lij_const public subroutine lij_const (self, T, lij) Arguments Type Intent Optional Attributes Name class( lij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: lij (:,:) Binary repulsive parameter matrix Source Code type :: lij_constant !! Constant l_{ij} real ( wp ), allocatable :: lij (:, :) !! l_{ij} values contains procedure :: get_lij => lij_const end type lij_constant","tags":"","loc":"type/lij_constant.html"},{"title":"a_parameter – Multicomponent Equations of State","text":"public subroutine a_parameter(self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate Contents Variables Tc Tr ac k Source Code a_parameter Variables Type Visibility Attributes Name Initial real(kind=8), public :: Tc real(kind=8), public :: Tr real(kind=8), public :: ac real(kind=8), public :: k Source Code subroutine a_parameter ( self , T ) !! Calculate the atractive parameter at T temperature. !! the subroutine will read the mixture's model and based on that !! will use the corresponding rule. class ( pure_compound ) :: self real ( 8 ), intent ( in ) :: T !! Temperature where to calculate real ( 8 ) :: Tr real ( 8 ) :: ac , k , Tc Tc = self % Tc ac = self % ac k = self % k Tr = T / Tc select type ( self ) class is ( rkpr ) self % a = ac * ( 3 / ( 2 + Tr )) ** k self % dadT = - k * self % a / Tc / ( 2 + Tr ) self % da2dT2 = - ( k + 1 ) * self % dadT / Tc / ( 2 + Tr ) class default self % a = ac * ( 1 + k * ( 1 - sqrt ( Tr ))) ** 2 self % dadT = ac * k * ( k - ( k + 1 ) / sqrt ( Tr )) / Tc self % da2dT2 = ac * k * ( k + 1 ) / ( 2 * Tc ** 2 * Tr ** 1.5 ) end select end subroutine a_parameter","tags":"","loc":"proc/a_parameter.html"},{"title":"mix – Multicomponent Equations of State","text":"public subroutine mix(self, T) Arguments Type Intent Optional Attributes Name class( mixture ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K] Contents Variables a b bij da2dt2 dadt dkij2dt2 dkijdt i kij lij nc Source Code mix Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: a (:) real(kind=wp), public, allocatable :: b (:) real(kind=wp), public, allocatable :: bij (:,:) real(kind=wp), public, allocatable :: da2dt2 (:) real(kind=wp), public, allocatable :: dadt (:) real(kind=wp), public, allocatable :: dkij2dt2 (:,:) real(kind=wp), public, allocatable :: dkijdt (:,:) integer, public :: i real(kind=wp), public, allocatable :: kij (:,:) real(kind=wp), public, allocatable :: lij (:,:) integer, public :: nc Source Code subroutine mix ( self , T ) class ( mixture ) :: self !! Mixture object real ( wp ), intent ( in ) :: T !! Temperature [K] real ( wp ), allocatable :: a (:) real ( wp ), allocatable :: dadt (:) real ( wp ), allocatable :: da2dt2 (:) real ( wp ), allocatable :: b (:), bij (:, :), lij (:, :) real ( wp ), allocatable :: kij (:, :), dkijdt (:, :), dkij2dt2 (:, :) integer :: i , nc nc = size ( self % compounds ) ! ======================================================================= !   Calculate all the pure compounds atractive and repulsive !    parameters at T ! ----------------------------------------------------------------------- allocate ( a ( nc )) allocate ( dadt ( nc )) allocate ( da2dt2 ( nc )) allocate ( b ( nc )) do i = 1 , nc call self % compounds ( i )% a_t ( T ) a ( i ) = self % compounds ( i )% a dadt ( i ) = self % compounds ( i )% dadt da2dt2 ( i ) = self % compounds ( i )% da2dt2 b ( i ) = self % compounds ( i )% b end do ! ======================================================================= ! ======================================================================= !  Calculate the kij and lij matrices ! ----------------------------------------------------------------------- associate ( kij_rule => self % kij_calculator ) select type ( kij_rule ) type is ( kij_constant ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) type is ( kij_exp_t ) call kij_rule % get_kij ( T , kij , dkijdt , dkij2dt2 ) class default print * , \"Not implemented Kij rule\" end select end associate associate ( lij_rule => self % lij_calculator ) select type ( lij_rule ) type is ( lij_constant ) call lij_rule % get_lij ( T , lij ) class default print * , \"Not implemented Kij rule\" end select self % kij_matrix = kij self % lij_matrix = lij end associate ! ======================================================================= ! ======================================================================= ! Calculate each aij ! ----------------------------------------------------------------------- allocate ( self % aij ( nc , nc )) allocate ( self % bij ( nc , nc )) do i = 1 , nc self % aij ( i , :) = sqrt ( a ( i ) * a ) * ( 1 - kij ( i , :)) self % bij ( i , :) = ( 1 - lij ( i , :)) * ( b ( i ) + b (:)) / 2 end do ! ======================================================================= end subroutine mix","tags":"","loc":"proc/mix.html"},{"title":"kij_const – Multicomponent Equations of State","text":"public subroutine kij_const(self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix Contents Source Code kij_const Source Code subroutine kij_const ( self , T , kij , dkijdt , dkij2dt2 ) class ( kij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix kij = self % kij dkijdt = 0 * kij dkij2dt2 = 0 * kij end subroutine kij_const","tags":"","loc":"proc/kij_const.html"},{"title":"kij_tdep – Multicomponent Equations of State","text":"public subroutine kij_tdep(self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix Contents Variables T_star kij_0 kij_inf nc sp Source Code kij_tdep Variables Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) real(kind=wp), public, allocatable :: kij_0 (:,:) real(kind=wp), public, allocatable :: kij_inf (:,:) integer, public :: nc integer, public :: sp (2) Source Code subroutine kij_tdep ( self , T , kij , dkijdt , dkij2dt2 ) implicit none class ( kij_exp_t ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: kij (:, :) !! Binary interaction parameter matrix real ( wp ), allocatable , intent ( out ) :: dkijdt (:, :) !! Binary interaction parameter first derivative with T matrix real ( wp ), allocatable , intent ( out ) :: dkij2dt2 (:, :) !! Binary interaction parameter second derivative with T matrix real ( wp ), allocatable :: kij_inf (:, :), kij_0 (:, :), T_star (:, :) integer :: nc , sp ( 2 ) kij_0 = self % kij_0 kij_inf = self % kij_inf T_star = self % T_star sp = shape ( self % kij_0 ) nc = sp ( 1 ) allocate ( kij ( nc , nc )) allocate ( dkijdt ( nc , nc )) allocate ( dkij2dt2 ( nc , nc )) kij = kij_inf + kij_0 * exp ( - T / T_star ) dkijdt = - kij_0 / T_star * exp ( - T / T_star ) dkij2dt2 = kij_0 / T_star ** 2 * exp ( - T / T_star ) self % kij = kij self % dkijdt = dkijdt self % dkij2dt2 = dkij2dt2 end subroutine kij_tdep","tags":"","loc":"proc/kij_tdep.html"},{"title":"lij_const – Multicomponent Equations of State","text":"public subroutine lij_const(self, T, lij) Arguments Type Intent Optional Attributes Name class( lij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: lij (:,:) Binary repulsive parameter matrix Contents Source Code lij_const Source Code subroutine lij_const ( self , T , lij ) class ( lij_constant ) :: self real ( wp ), intent ( in ) :: T !! Temperature real ( wp ), allocatable , intent ( out ) :: lij (:, :) !! Binary repulsive parameter matrix lij = self % lij end subroutine lij_const","tags":"","loc":"proc/lij_const.html"},{"title":"quadratic – Multicomponent Equations of State","text":"public subroutine quadratic(nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix Contents Variables i j Source Code quadratic Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j Source Code subroutine quadratic ( nc , a , b , kij , dadt , da2dt2 , dkijdt , dkij2dt2 , lij , aij , daijdt , daij2dt2 , bij ) !! Classic quadratic mixing rules. integer , intent ( in ) :: nc !! Number of components real ( wp ), intent ( in ) :: a ( nc ) !! Atractive parameter at working temperature real ( wp ), intent ( in ) :: b ( nc ) !! Repulsive parameter real ( wp ), intent ( in ) :: kij ( nc , nc ) !! Kij matrix real ( wp ), intent ( in ) :: dadt ( nc ) !! First derivative with T real ( wp ), intent ( in ) :: da2dt2 ( nc ) !! Second derivative with T real ( wp ), intent ( in ) :: dkijdt ( nc , nc ) !! Kij matrix first derivative real ( wp ), intent ( in ) :: dkij2dt2 ( nc , nc ) !! Kij matrix second derivative real ( wp ), intent ( in ) :: lij ( nc , nc ) !! Lij matrix real ( wp ), intent ( out ) :: aij ( nc , nc ) !! Binary atractive parameters matrix real ( wp ), intent ( out ) :: daijdt ( nc , nc ) !! First derivative with T real ( wp ), intent ( out ) :: daij2dt2 ( nc , nc ) !! Second derivative with T real ( wp ), intent ( out ) :: bij ( nc , nc ) !! Repulse parameter matrix integer :: i , j do i = 1 , nc aij ( i , i ) = a ( i ) daijdT ( i , i ) = dadT ( i ) daij2dT2 ( i , i ) = da2dT2 ( i ) do j = 1 , nc aij ( j , i ) = sqrt ( a ( i ) * a ( j )) * ( 1 - kij ( j , i )) aij ( i , j ) = aij ( j , i ) daijdt ( j , i ) = ( 1 - Kij ( j , i )) * ( sqrt ( a ( i ) / a ( j )) * dadT ( j ) + sqrt ( a ( j ) / a ( i )) * dadT ( i )) / 2 & - dkijdt ( j , i ) * sqrt ( a ( j ) * a ( i )) daijdt ( i , j ) = daijdT ( j , i ) daij2dt2 ( j , i ) = ( 1 - Kij ( j , i )) * ( dadt ( j ) * dadt ( i ) / sqrt ( a ( i ) * a ( j )) & + sqrt ( a ( i ) / a ( j )) * ( da2dt2 ( j ) - dadt ( j ) ** 2 / ( 2 * a ( j ))) & + sqrt ( a ( j ) / a ( i )) * ( da2dt2 ( i ) - dadt ( i ) ** 2 / ( 2 * a ( i )))) / 2 & - dkijdt ( j , i ) * ( a ( j ) * dadt ( i ) + a ( i ) * dadt ( j )) / sqrt ( a ( j ) * a ( i )) & - dkij2dt2 ( j , i ) * sqrt ( a ( j ) * a ( i )) daij2dT2 ( i , j ) = daij2dT2 ( j , i ) bij ( i , j ) = ( 1 - lij ( i , j )) * ( b ( i ) + b ( j )) / 2 bij ( j , i ) = bij ( i , j ) end do end do end subroutine quadratic","tags":"","loc":"proc/quadratic.html"},{"title":"constants – Multicomponent Equations of State","text":"Used by module~~constants~~UsedByGraph module~constants constants module~rkpr rkpr module~rkpr->module~constants module~mixing_rules mixing_rules module~mixing_rules->module~constants module~cubic_eos cubic_eos module~cubic_eos->module~constants module~cubic_eos->module~mixing_rules module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~constants module~multicomponent_eos->module~mixing_rules module~multicomponent_eos->module~cubic_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables A0 A1 B0 B1 C0 C1 Dfit ERRMAX RGAS wp Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: A0 = 0.0017 real(kind=wp), public, parameter :: A1 = -2.4407 real(kind=wp), public, parameter :: B0 = 1.9681 real(kind=wp), public, parameter :: B1 = 7.4513 real(kind=wp), public, parameter :: C0 = -2.7238 real(kind=wp), public, parameter :: C1 = 12.504 real(kind=wp), public, dimension(6) :: Dfit = [0.428363, 18.496215, 0.338426, 0.660, 789.723105, 2.512392] real(kind=wp), public, parameter :: ERRMAX = 1.D-8 real(kind=wp), public, parameter :: RGAS = 0.08314472d0 integer, public, parameter :: wp = 8","tags":"","loc":"module/constants.html"},{"title":"cubic_eos – Multicomponent Equations of State","text":"Module that encompass the calculations of the residual Helmholtz energy\nand related properties like fugacity coefficents. Uses constants mixing_rules module~~cubic_eos~~UsesGraph module~cubic_eos cubic_eos module~mixing_rules mixing_rules module~cubic_eos->module~mixing_rules module~constants constants module~cubic_eos->module~constants module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~cubic_eos~~UsedByGraph module~cubic_eos cubic_eos module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~cubic_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types pr pure_compound rkpr srk Subroutines a_parameter Derived Types type, public, extends( pure_compound ) :: pr Peng-Robinson EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public :: pure_compound Generic EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: rkpr Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: del1 real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter type, public, extends( pure_compound ) :: srk Soave-Redlich-Kwong EoS Components Type Visibility Attributes Name Initial real(kind=8), public :: a = 0 Atractive parameter valuated at temperature real(kind=8), public :: ac Critical atractive parameter real(kind=8), public :: b Repulsive parameter real(kind=8), public :: da2dt2 = 0 Atractive parameter second derivative with tempetarue real(kind=8), public :: dadt = 0 Atractive parameter first derivative with tempetarue real(kind=8), public :: k Atractive parameter constant character(len=100), public :: name Compound name real(kind=8), public :: pc Critical pressure real(kind=8), public :: tc Critical temperature real(kind=8), public :: w Accentric factor Type-Bound Procedures procedure, public :: a_t => a_parameter Subroutines public subroutine a_parameter (self, T) Calculate the atractive parameter at T temperature.\nthe subroutine will read the mixture’s model and based on that\nwill use the corresponding rule. Arguments Type Intent Optional Attributes Name class( pure_compound ) :: self real(kind=8), intent(in) :: T Temperature where to calculate","tags":"","loc":"module/cubic_eos.html"},{"title":"multicomponent_eos – Multicomponent Equations of State","text":"Uses constants mixing_rules cubic_eos module~~multicomponent_eos~~UsesGraph module~multicomponent_eos multicomponent_eos module~mixing_rules mixing_rules module~multicomponent_eos->module~mixing_rules module~constants constants module~multicomponent_eos->module~constants module~cubic_eos cubic_eos module~multicomponent_eos->module~cubic_eos module~mixing_rules->module~constants module~cubic_eos->module~mixing_rules module~cubic_eos->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types mixture Subroutines mix Derived Types type, public :: mixture Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: aij (:,:) real(kind=wp), public, allocatable :: bij (:,:) class( pure_compound ), public, allocatable :: compounds (:) class( kij_constant ), public, allocatable :: kij_calculator real(kind=wp), public, allocatable :: kij_matrix (:,:) class( lij_constant ), public, allocatable :: lij_calculator real(kind=wp), public, allocatable :: lij_matrix (:,:) Type-Bound Procedures procedure, public :: mix Subroutines public subroutine mix (self, T) Arguments Type Intent Optional Attributes Name class( mixture ) :: self Mixture object real(kind=wp), intent(in) :: T Temperature [K]","tags":"","loc":"module/multicomponent_eos.html"},{"title":"rkpr – Multicomponent Equations of State","text":"Uses constants module~~rkpr~~UsesGraph module~rkpr rkpr module~constants constants module~rkpr->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/rkpr.html"},{"title":"mixing_rules – Multicomponent Equations of State","text":"Module that contains the available mixing rules to be used. Uses constants module~~mixing_rules~~UsesGraph module~mixing_rules mixing_rules module~constants constants module~mixing_rules->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mixing_rules~~UsedByGraph module~mixing_rules mixing_rules module~cubic_eos cubic_eos module~cubic_eos->module~mixing_rules module~multicomponent_eos multicomponent_eos module~multicomponent_eos->module~mixing_rules module~multicomponent_eos->module~cubic_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types kij_constant kij_exp_t lij_constant Subroutines kij_const kij_tdep lij_const quadratic Derived Types type, public :: kij_constant constant type Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: kij (:,:) matrix Type-Bound Procedures procedure, public :: get_kij => kij_const type, public, extends( kij_constant ) :: kij_exp_t Kij with temperature dependance according to the equation: The parameters of the equation are obtained from the mixture module. Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: T_star (:,:) Reference temperature real(kind=wp), public, allocatable :: dkij2dt2 (:,:) matrix real(kind=wp), public, allocatable :: dkijdt (:,:) matrix real(kind=wp), public, allocatable :: kij (:,:) matrix real(kind=wp), public, allocatable :: kij_0 (:,:) Exponential real(kind=wp), public, allocatable :: kij_inf (:,:) K_ij at infinite Temperature Type-Bound Procedures procedure, public :: get_kij => kij_tdep type, public :: lij_constant Constant Components Type Visibility Attributes Name Initial real(kind=wp), public, allocatable :: lij (:,:) values Type-Bound Procedures procedure, public :: get_lij => lij_const Subroutines public subroutine kij_const (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix public subroutine kij_tdep (self, T, kij, dkijdt, dkij2dt2) Arguments Type Intent Optional Attributes Name class( kij_exp_t ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: kij (:,:) Binary interaction parameter matrix real(kind=wp), intent(out), allocatable :: dkijdt (:,:) Binary interaction parameter first derivative with T matrix real(kind=wp), intent(out), allocatable :: dkij2dt2 (:,:) Binary interaction parameter second derivative with T matrix public subroutine lij_const (self, T, lij) Arguments Type Intent Optional Attributes Name class( lij_constant ) :: self real(kind=wp), intent(in) :: T Temperature real(kind=wp), intent(out), allocatable :: lij (:,:) Binary repulsive parameter matrix public subroutine quadratic (nc, a, b, kij, dadt, da2dt2, dkijdt, dkij2dt2, lij, aij, daijdt, daij2dt2, bij) Classic quadratic mixing rules. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nc Number of components real(kind=wp), intent(in) :: a (nc) Atractive parameter at working temperature real(kind=wp), intent(in) :: b (nc) Repulsive parameter real(kind=wp), intent(in) :: kij (nc,nc) Kij matrix real(kind=wp), intent(in) :: dadt (nc) First derivative with T real(kind=wp), intent(in) :: da2dt2 (nc) Second derivative with T real(kind=wp), intent(in) :: dkijdt (nc,nc) Kij matrix first derivative real(kind=wp), intent(in) :: dkij2dt2 (nc,nc) Kij matrix second derivative real(kind=wp), intent(in) :: lij (nc,nc) Lij matrix real(kind=wp), intent(out) :: aij (nc,nc) Binary atractive parameters matrix real(kind=wp), intent(out) :: daijdt (nc,nc) First derivative with T real(kind=wp), intent(out) :: daij2dt2 (nc,nc) Second derivative with T real(kind=wp), intent(out) :: bij (nc,nc) Repulse parameter matrix","tags":"","loc":"module/mixing_rules.html"},{"title":"main – Multicomponent Equations of State","text":"Uses json_module program~~main~~UsesGraph program~main main json_module json_module program~main->json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables found i id json_data kij kijs n name z Source Code main Variables Type Attributes Name Initial logical :: found integer :: i character(len=50) :: id type(json_file) :: json_data real(kind=8), allocatable :: kij (:) real(kind=8), allocatable :: kijs (:,:) integer :: n character(len=:), allocatable :: name real(kind=8), allocatable :: z (:) Source Code program main use json_module implicit none type ( json_file ) :: json_data logical :: found integer :: n , i real ( 8 ), allocatable :: z (:) real ( 8 ), allocatable :: kijs (:, :) real ( 8 ), allocatable :: kij (:) character * 50 :: id character ( len = :), allocatable :: name call json_data % initialize () call json_data % load ( \"mixfile.json\" ) call json_data % print () call json_data % get ( 'z' , z , found ) n = size ( z ) do i = 1 , n write ( id , * ) i id = trim ( 'compounds(' // trim ( adjustl ( id )) // ').name' ) print * , id call json_data % get ( id , name , found ) print * , name end do end program main","tags":"","loc":"program/main.html"},{"title":"Multi – Multicomponent Equations of State","text":"Fortran program for the calculation of the residual Helmholtz Energy using the\nRKPR EoS (hence, PR and SRK are also included), for multicomponent mixtures.","tags":"","loc":"page//index.html"}]}